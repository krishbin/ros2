diff --git a/wiimote/CHANGELOG.rst b/wiimote/CHANGELOG.rst
deleted file mode 100644
index 8429bab..0000000
--- a/wiimote/CHANGELOG.rst
+++ /dev/null
@@ -1,63 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package wiimote
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-3.1.0 (2022-01-28)
-------------------
-* Install includes to include/ and misc CMake fixes (`#225 <https://github.com/ros-drivers/joystick_drivers/issues/225>`_)
-* Style fixes for newer cpplint.
-* Contributors: Chris Lalancette, Shane Loretz
-
-3.0.1 (2022-01-28)
-------------------
-
-3.0.0 (2021-03-12)
-------------------
-* Fix a warning while building wiimote_controller.cpp (`#201 <https://github.com/ros-drivers/joystick_drivers/issues/201>`_)
-* fix compile error caused by missing include (`#197 <https://github.com/ros-drivers/joystick_drivers/issues/197>`_)
-* Port over Wiimote to ROS2 Foxy (`#175 <https://github.com/ros-drivers/joystick_drivers/issues/175>`_)
-* Contributors: Chris Lalancette, Kuni Natsuki, Kurt Wilson
-
-1.13.0 (2019-06-24)
--------------------
-* Merge pull request `#132 <https://github.com/ros-drivers/joystick_drivers/issues/132>`_ from mistoll/clean_exit
-* return instead of shutdown
-* Merge pull request `#128 <https://github.com/ros-drivers/joystick_drivers/issues/128>`_ from ros-drivers/fix/tab_errors
-* Cleaning up Python indentation.
-* Merge pull request `#125 <https://github.com/ros-drivers/joystick_drivers/issues/125>`_ from mistoll/check_connection
-* Check if wiimote is still connected.
-* Merge pull request `#123 <https://github.com/ros-drivers/joystick_drivers/issues/123>`_ from cclauss/modernize-python2-code
-* Modernize Python 2 code to get ready for Python 3
-* Merge branch 'master' into indigo-devel
-* Contributors: Joshua Whitley, Matthew, Michael Stoll, cclauss
-
-1.12.0 (2018-06-11)
--------------------
-* Addressed numerous outstanding PRs.
-* Fixed issue when nunchuk wasn't connected
-* Update README.md
-* Added testing proceedures for wiimote
-* Resolved div-by-zero error race condition on startup.
-* Added testing proceedures for wiimote
-* Fixed issue when nunchuk wasn't connected
-* Changed package xml to format 2
-* Added wiimote testing script
-* Add pairing params to wiimote_node
-  * bluetooth_addr
-  * pair_timeout
-* Contributors: Jonathan Bohren, Matt Vollrath, jprod123, psimona
-
-1.11.0 (2017-02-10)
--------------------
-* Sample Teleop Implementation for Wiimote
-* C++ Implementation of Wiimote Controller Node
-* Add queue_size to remove ROS Warning
-* Update dependencies to remove warnings
-* Contributors: Mark D Horn
-
-1.10.1 (2015-05-24)
--------------------
-
-1.10.0 (2014-06-26)
--------------------
-* First indigo release
diff --git a/wiimote/CMakeLists.txt b/wiimote/CMakeLists.txt
deleted file mode 100644
index b647278..0000000
--- a/wiimote/CMakeLists.txt
+++ /dev/null
@@ -1,113 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(wiimote)
-
-# Default to C99
-if(NOT CMAKE_C_STANDARD)
-  set(CMAKE_C_STANDARD 99)
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic)
-endif()
-
-include(wiimote-extras.cmake)
-
-find_package(ament_cmake REQUIRED)
-find_package(geometry_msgs REQUIRED)
-find_package(rclcpp REQUIRED)
-find_package(rclcpp_components REQUIRED)
-find_package(rclcpp_lifecycle REQUIRED)
-find_package(sensor_msgs REQUIRED)
-find_package(std_msgs REQUIRED)
-find_package(std_srvs REQUIRED)
-find_package(wiimote_msgs REQUIRED)
-
-## C++ Wiimote Lib
-add_library(wiimote_lib SHARED
-  src/wiimote_controller.cpp
-  src/stat_vector_3d.cpp)
-target_include_directories(wiimote_lib PUBLIC
-  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
-  "$<INSTALL_INTERFACE:include/${PROJECT_NAME}>")
-target_link_libraries(wiimote_lib PUBLIC
-  rclcpp::rclcpp
-  rclcpp_lifecycle::rclcpp_lifecycle
-  ${sensor_msgs_TARGETS}
-  ${std_msgs_TARGETS}
-  ${std_srvs_TARGETS}
-  ${wiimote_msgs_TARGETS}
-  wiimote::bluetooth
-  wiimote::cwiid)
-target_link_libraries(wiimote_lib PRIVATE
-  rclcpp_components::component)
-
-rclcpp_components_register_node(
-  wiimote_lib
-  PLUGIN "WiimoteNode"
-  EXECUTABLE wiimote_node
-)
-## End C++ Wiimote Lib
-
-# C++ Teleop for Wiimote Node: Declare cpp executables
-add_library(teleop_wiimote SHARED
-  src/teleop_wiimote.cpp)
-target_include_directories(teleop_wiimote PUBLIC
-  "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
-  "$<INSTALL_INTERFACE:include/${PROJECT_NAME}>")
-target_link_libraries(teleop_wiimote PUBLIC
-  rclcpp::rclcpp
-  rclcpp_lifecycle::rclcpp_lifecycle
-  ${geometry_msgs_TARGETS}
-  ${sensor_msgs_TARGETS}
-  ${wiimote_msgs_TARGETS})
-target_link_libraries(teleop_wiimote PRIVATE
-  rclcpp_components::component)
-
-rclcpp_components_register_node(
-  teleop_wiimote
-  PLUGIN "TeleopWiimote"
-  EXECUTABLE teleop_wiimote_node
-)
-# End C++ Teleop for Wiimote Node
-
-if(BUILD_TESTING)
-  find_package(ament_lint_auto REQUIRED)
-  ament_lint_auto_find_test_dependencies()
-endif()
-
-# Install lib
-install(TARGETS wiimote_lib teleop_wiimote EXPORT export_wiimote
-  ARCHIVE DESTINATION lib
-  LIBRARY DESTINATION lib
-  RUNTIME DESTINATION bin)
-install(DIRECTORY include/ DESTINATION include/${PROJECT_NAME})
-
-# Install launch and config files
-install(DIRECTORY launch config
-  DESTINATION share/${PROJECT_NAME})
-
-# Install Executables
-install(TARGETS wiimote_node
-  DESTINATION lib/${PROJECT_NAME})
-
-install(PROGRAMS nodes/feedback_tester.py
-  DESTINATION lib/${PROJECT_NAME}
-)
-
-ament_export_targets(export_wiimote)
-ament_export_dependencies(
-  "rclcpp"
-  "sensor_msgs"
-  "std_msgs"
-  "std_srvs"
-  "wiimote"
-)
-
-ament_package(
-  CONFIG_EXTRAS "wiimote-extras.cmake"
-)
diff --git a/wiimote/LICENSE b/wiimote/LICENSE
deleted file mode 100644
index d159169..0000000
--- a/wiimote/LICENSE
+++ /dev/null
@@ -1,339 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-                            NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff --git a/wiimote/README.md b/wiimote/README.md
deleted file mode 100644
index e13a086..0000000
--- a/wiimote/README.md
+++ /dev/null
@@ -1,39 +0,0 @@
-# Wiimote Nodes
-
-Additional Documentation
- * [Testing procedure](doc/testing.md)
- * [ROS Wiki](http://wiki.ros.org/wiimote)
- 
-Tutorials
- * [Teleop with Wiimote](doc/tutorials/teleop.md)
-
-## wiimote_node.py
-
-Original Python version of the wiimote node.
-
-## wiimote_node
-
-The C++ implementation was designed with focus on reduced resource consumption.
-
-### Parameters
-
-* `bluetooth_addr` [str] - Bluetooth address for pairing. Default: `00:00:00:00:00:00` (first device)
-* `pair_timeout` [int] - Pair timeout in seconds. `-1` means never timeout. Default: `5`
-
-### Differences from Python Implementation
-* Both "/wiimote/nunchuk" and "/wiimote/classic" topics are only published
-if the Nunchuk or Classic Controller are connected to the wiimote respectively.
-* Wiimote data is only polled from the controller if the data is required
-to publish for a topic which has at least one subscriber.
-* During Calibration the joysticks (Nunchuk & Classic Controller) are polled
-to find the current position which is assumed to be the center. Not all joysticks
-rest at the theoretical center position.
-* Joysticks (Nunchuk & Classic Controller) minimum and maximum values start at
-80% of the theoretical minimum/maximum values and are dynamically updated as
-the joystick is used. The full range of values may not be reached on all joysticks
-due to physical limitations. Without this adjust, the full range from -1.0 to 1.0
-would not be reached on many joysticks.
-* Joysticks (Nunchuk & Classic Controller) center deadzone is scaled based on
-the granularity of the joystick; python code assumed the same for all.
-* Connecting an accessory (Nunchuk, Classic Controller, or MotionPlus) will
-automatically start a new calibration sequence.
diff --git a/wiimote/config/teleop_wiimote_params.yaml b/wiimote/config/teleop_wiimote_params.yaml
deleted file mode 100644
index b288a3d..0000000
--- a/wiimote/config/teleop_wiimote_params.yaml
+++ /dev/null
@@ -1,12 +0,0 @@
-/**:
-  ros__parameters:
-    linear:
-      x:
-        max_velocity: 0.65024
-        min_velocity: -0.65024
-        throttle_percent: 0.75
-    angular:
-      z:
-        max_velocity: 3.14159265358979323846
-        min_velocity: -3.14159265358979323846
-        throttle_percent: 0.75
diff --git a/wiimote/config/wiimote_params.yaml b/wiimote/config/wiimote_params.yaml
deleted file mode 100644
index c77db66..0000000
--- a/wiimote/config/wiimote_params.yaml
+++ /dev/null
@@ -1,9 +0,0 @@
-/**:
-  ros__parameters:
-    bluetooth_addr: "00:00:00:00:00:00"
-    pair_timeout: -1
-    check_connection_interval: 1.0
-    publish_interval: .2
-    require_nunchuk: true
-    require_classic: false
-    require_motionplus: false
diff --git a/wiimote/doc/testing.md b/wiimote/doc/testing.md
deleted file mode 100644
index 8520209..0000000
--- a/wiimote/doc/testing.md
+++ /dev/null
@@ -1,175 +0,0 @@
-# Testing procedures for the WiiMote package
-
-### Python compatiblity test script ###
-After building the package the first thing one should run is the python test script
-
-The script will look for compatible Wiimotes. The package is **not** compatible with the newer Wiimotes. The compatible Wiimotes are the **Nintendo RVL-CNT-01** and **Nintendo RVL-WBC-01**.
-
-```
-$ python wiimote/scripts/wiimote_test.py
-Looking for compatible devices
-Incompatible controller:
- CC:FB:65:E6:62:1D - Nintendo RVL-CNT-01-TR
-Compatible controller:
- 00:17:AB:37:FF:5E - Nintendo RVL-CNT-01
-```
-
-In the above example two wiimotes were deteced but only one is compatible with the wiimote package.
-
----
-
-### Running the wiimote nodes ###
-The package consists of two primary nodes:
->wiimote_node
-wiimote_node.py
-
-The C++ implementation was design with focus on reduced resource consumption and is recommended over the python variant.
-
----
-
-#### Wiimote_node ####
-
-Running the wiimote_node is straight forward, ensure bluetooth is enabled on your machine and put the Wiimote in discoverable mode (press 1+2)
-
-```
-$ rosrun wiimote wiimote_node
-[ INFO] [1498662258.081403347]: * * * Pairing
-[ INFO] [1498662258.081474540]: Allow all joy sticks to remain at center position until calibrated.
-[ INFO] [1498662258.081506464]: Put Wiimote in discoverable mode now (press 1+2)...
-[ INFO] [1498662258.081540133]: Timeout in about 5 seconds if not paired.
-[ INFO] [1498662835.763122784]: Collecting additional calibration data; keep wiimote stationary...
-[ INFO] [1498662836.780853688]: Wiimote is Paired
-```
-The wiimote is now paired and is publisihing to several different topics. Listing the Ros topics should yield something similar to:
-
-```
-$ rostopic list
-/imu/data
-/imu/is_calibrated
-/joy
-/joy/set_feedback
-/rosout
-/rosout_agg
-/wiimote/state
-```
-##### Possible Errors #####
-
->If the Wiimote fails to connect try pressing the red sync button on the back of the remote and run the node again. The script could also be timing out before it is able to find the Wiimote aswell. If this is suspected try running the node with the following parameters:
-`
-$ rosrun wiimote wiimote_node _pair_timeout:=-1
-`
->This will make the script search indefinitly until closed.
-
-To see if the Wiimote is working properly echo the /wiimote/state topic
-```
-$rostopic echo /wiimote/state
----
-header:
-  seq: 485
-  stamp:
-    secs: 1498664301
-    nsecs: 333370601
-  frame_id: ''
-angular_velocity_zeroed:
-  x: 0.0
-  y: 0.0
-  z: 0.0
-angular_velocity_raw:
-  x: 0.0
-  y: 0.0
-  z: 0.0
-angular_velocity_covariance: [-1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-linear_acceleration_zeroed:
-  x: 1.63444166667
-  y: 0.338160344828
-  z: 9.80665
-linear_acceleration_raw:
-  x: 144.0
-  y: 140.0
-  z: 161.0
-linear_acceleration_covariance: [0.0, 0.0, 0.0, 0.0, 0.7766074343434308, 0.0, 0.0, 0.0, 1.1203354696969712]
-nunchuk_acceleration_zeroed:
-  x: 0.0
-  y: 0.0
-  z: 0.0
-nunchuk_acceleration_raw:
-  x: 0.0
-  y: 0.0
-  z: 0.0
-nunchuk_joystick_zeroed: [0.0, 0.0]
-nunchuk_joystick_raw: [0.0, 0.0]
-buttons: [False, False, False, False, False, False, False, False, False, False, False]
-nunchuk_buttons: [False, False]
-LEDs: [False, False, False, False]
-rumble: False
-ir_tracking:
-  -
-    x: -1.0
-    y: -1.0
-    ir_size: -1
-  -
-    x: -1.0
-    y: -1.0
-    ir_size: -1
-  -
-    x: -1.0
-    y: -1.0
-    ir_size: -1
-  -
-    x: -1.0
-    y: -1.0
-    ir_size: -1
-raw_battery: 155.0
-percent_battery: 74.5192337036
-zeroing_time:
-  secs: 1498662949
-  nsecs: 612081279
-errors: 0
----
-```
-
-Test it out! Move the Wiimote and see the corresponding values change on the terminal.
-
----
-### Wiimote_node.py ###
-The process for the python variant is similar to the C++ version. Put the Wiimote in discoverable mode (press 1+2) and run the script.
-
-```
-$ rosrun wiimote wiimote_node.py
-Press buttons 1 and 2 together to pair (within 6 seconds).
-    (If no blinking lights, press power button for ~3 seconds.)
-```
-Echo the output onto the screen using the same `$ rosparam echo /wiimote/state` used above.
-
-
-### Topics ###
-##### Subscribed topics #####
-* set_feedback (sensor_msgs/JoyFeedbackArray)
-*Topic where ROS clients control the Wiimote's leds and rumble (vibrator) facility.* 
-
-##### Published Topics #####
-* joy (joy/Joy) 
-
-   *Topic on which Wiimote accelerometer, gyro, and button data are published. Axes are: linear AccelerationX/Y/Z, followed by angular velocityX/Y/Z (a.k.a. Roll, Pitch, Yaw, a.k.a. Phi, Theta, Psi). The values are corrected to be near zero at rest. For raw values, use the State message. The Wiimote buttons are reported in the same order as in the State message*  
-
-* imu/data (sensor_msgs/Imu) 
-
-   *Topic on which Wiimote gyro and accelerometer data are sent out.*  
-
-* wiimote/state (wiimote/State)
-
-   *Topic for comprehensive information about Wiimote state.*  
-
-* wiimote/nunchuk (joy/Joy)
-
-   *Topic on which data from an attached Nunchuk are sent out, including the joystick, accelerometer and button data. Axes are: Joystick X/Y, Acceleration X/Y/Z. The buttons are Z then C. Note the spelling of the topic name does not include a 'c'.*  
-
-* wiimote/classic (joy/Joy)
-
-   *Topic on which data for a Wiimote classic attachment are sent out (Untested by Willow Garage).*  
-
-* imu/is_calibrated (std_msgs/Bool)
-
-   *Latched topic for learning the most recent Wiimote calibration result.*  
-
-
diff --git a/wiimote/doc/tutorials/teleop.md b/wiimote/doc/tutorials/teleop.md
deleted file mode 100644
index 87c20da..0000000
--- a/wiimote/doc/tutorials/teleop.md
+++ /dev/null
@@ -1,77 +0,0 @@
-# Wiimote Teleop Sample Node
-
-This sample ROS Node subscribes to the wiimote topics
-
-    /wiimote/nunchuk
-    /wiimote/state
-
-And publishes command velocity used for motion
-
-    /cmd_vel
-
-Either the four way D-pad of the Wiimote or the Joystick of the Nunchuk
-can be used for controlling the values published for `/cmd_vel`.
-**Note:** The Joystick and D-pad are mutually exclusive; if one is in
-use the other is ignored.
-
-## ROS parameters
-    base (string)
-Base name space string to prepend to velocity ROS parameters.
-
-    linear/x/max_velocity (double)
-Maximum linear velocity (in m/s)
-
-    linear/x/min_velocity (double)
-Minimum linear velocity (in m/s). Setting this to 0.0 will disable backwards
-motion. When unspecified, -max_velocity is used.
-
-    angular/z/max_velocity (double)
-Maximum angular velocity (in rad/s)
-
-    angular/z/min_velocity (double)
-Minimum angular velocity (in rad/s). Setting this to 0.0 will disable
-counter-clockwise rotation. When unspecified, -max_velocity is used.
-
-    linear/x/throttle_percent (double)
-Default linear throttle percentage (0.0 to 1.0). Adjustable via the
-'1' and '+/-' buttons on the Wiimote. Defaults to 0.75.
-Private parameter which does not use the 'base'.
-
-    angular/z/throttle_percent (double)
-Default angular throttle percentage (0.0 to 1.0). Adjustable via the
-'2' and '+/-' buttons on the Wiimote. Defaults to 0.75.
-Private parameter which does not use the 'base'.
-
-
-## Button Definitions
-| Button         | Function                           |
-|:--------------:| ---------------------------------- |
-| D-Pad Up       | Move Forward                       |
-| D-Pad Down     | Move Reverse                       |
-| D-Pad Left     | Turn/Spin Left                     |
-| D-Pad Right    | Turn/Spin Right                    |
-| B (Trigger)    | 2x Speed (up to Max)               |
-| A              | 1/4 Speed                          |
-|                |                                    |
-| Home           | Display Wiimote battery level      |
-|                |                                    |
-| 1\*            | Linear Throttle (defaults to 75%)  |
-| 2\*            | Angular Throttle (defaults to 75%) |
-| +              | Increase Throttle (rumbles at max) |
-| -              | Decrease Throttle (rumbles at min) |
-|                |                                    |
-| Joystick Up    | Move Forward                       |
-| Joystick Down  | Move Reverse                       |
-| Joystick Left  | Turn/Spin Left                     |
-| Joystick Right | Turn/Spin Right                    |
-| Z (Trigger)    | 2x Speed (up to Max)               |
-| C (Trigger)    | 1/4 Speed                          |
-|                |                                    |
-
-\* Throttle level displayed on Wiimote LEDs
-
-### Launch File Examples
-Launch files are provided with usage examples using the turtlebot
-simulator for both Python (turtlesim_py.launch) and C++ (turtlesim_cpp.launch).
-
-Requires the installation of ros-<release>-turtlesim ROS package.
diff --git a/wiimote/include/wiimote/stat_vector_3d.hpp b/wiimote/include/wiimote/stat_vector_3d.hpp
deleted file mode 100644
index 593d0b8..0000000
--- a/wiimote/include/wiimote/stat_vector_3d.hpp
+++ /dev/null
@@ -1,64 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * Three dimensional statistic vector for use with the
- * for ROS Node which interfaces with a wiimote control unit.
- */
-
-/*
- * Initial C++ implementation by
- *   Mark Horn <mark.d.horn@intel.com>
- *
- * Revisions:
- *
- */
-
-#pragma once
-#ifndef WIIMOTE__STAT_VECTOR_3D_HPP_
-#define WIIMOTE__STAT_VECTOR_3D_HPP_
-
-#include <vector>
-
-// The vector of 3 values collected to generate:
-// mean, standard deviation, and variance.
-
-typedef std::vector<double> TVectorDouble;
-
-class StatVector3d
-{
-public:
-  StatVector3d();
-  StatVector3d(int x, int y, int z);
-
-  void clear();
-
-  int size();
-  void addData(int x, int y, int z);
-
-  TVectorDouble getMeanRaw();
-  TVectorDouble getMeanScaled(double scale);
-  TVectorDouble getVarianceRaw();
-  TVectorDouble getVarianceScaled(double scale);
-  TVectorDouble getStandardDeviationRaw();
-  TVectorDouble getStandardDeviationScaled(double scale);
-
-private:
-  int count_;
-  std::vector<int> x_;
-  std::vector<int> y_;
-  std::vector<int> z_;
-};
-
-#endif  // WIIMOTE__STAT_VECTOR_3D_HPP_
diff --git a/wiimote/include/wiimote/teleop_wiimote.hpp b/wiimote/include/wiimote/teleop_wiimote.hpp
deleted file mode 100644
index 16c7109..0000000
--- a/wiimote/include/wiimote/teleop_wiimote.hpp
+++ /dev/null
@@ -1,80 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * ROS Node for using a wiimote control unit to direct a robot.
- */
-
-/*
- * Initial C++ implementation by
- *   Mark Horn <mark.d.horn@intel.com>
- *
- * Revisions:
- *
- */
-
-#pragma once
-#ifndef WIIMOTE__TELEOP_WIIMOTE_HPP_
-#define WIIMOTE__TELEOP_WIIMOTE_HPP_
-
-#include <rclcpp/rclcpp.hpp>
-#include <rclcpp_lifecycle/lifecycle_node.hpp>
-#include <sensor_msgs/msg/joy.hpp>
-#include <sensor_msgs/msg/joy_feedback_array.hpp>
-#include <geometry_msgs/msg/twist.hpp>
-#include <wiimote_msgs/msg/state.hpp>
-
-class TeleopWiimote : public rclcpp_lifecycle::LifecycleNode
-{
-public:
-  /**
-   * \brief rclcpp component-compatible constructor
-   * \param options
-   */
-  explicit TeleopWiimote(const rclcpp::NodeOptions & options);
-
-  CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
-
-private:
-  void rumble_feedback(std::chrono::milliseconds duration);
-  void set_led_feedback(double value);
-  void joy_callback(const sensor_msgs::msg::Joy::ConstSharedPtr & joy);
-  void wiimote_state_callback(const wiimote_msgs::msg::State::ConstSharedPtr & wiistate);
-
-  double linear_x_max_velocity_;   // m/s
-  double linear_x_min_velocity_;   // m/s
-  double angular_z_max_velocity_;  // rad/s
-  double angular_z_min_velocity_;  // rad/s
-
-  double percent_linear_throttle_;   // 0.0 - 1.0 (1.0 = 100%)
-  double percent_angular_throttle_;  // 0.0 - 1.0 (1.0 = 100%)
-
-  rclcpp::Logger logger_;
-
-  rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>::SharedPtr vel_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::JoyFeedbackArray>::SharedPtr joy_pub_;
-
-  rclcpp::Subscription<sensor_msgs::msg::Joy>::SharedPtr joy_sub_;
-  rclcpp::Subscription<wiimote_msgs::msg::State>::SharedPtr wiimote_sub_;
-
-  bool dpad_in_use_;
-  bool njoy_in_use_;
-};
-
-#endif  // WIIMOTE__TELEOP_WIIMOTE_HPP_
diff --git a/wiimote/include/wiimote/wiimote_controller.hpp b/wiimote/include/wiimote/wiimote_controller.hpp
deleted file mode 100644
index 504e20a..0000000
--- a/wiimote/include/wiimote/wiimote_controller.hpp
+++ /dev/null
@@ -1,256 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * ROS Node for interfacing with a wiimote control unit.
- */
-
-/*
- * This code is based on the original Python implementation
- * created by Andreas Paepcke and Melonee Wise
- *  Andreas Paepcke <paepcke@anw.willowgarage.com>
- * with contributions by
- *  David Lu <davidlu@wustl.edu>
- *  Miguel Angel Julian Aguilar <miguel.angel@thecorpora.com>
- * See https://github.com/ros-drivers/joystick_drivers/tree/indigo-devel/wiimote
- * for details and history.
- *
- * This C++ implementation used the functionality of the existing
- * Python code as the feature requirements.
- */
-
-/*
- * Initial C++ implementation by
- *   Mark Horn <mark.d.horn@intel.com>
- *
- * Revisions:
- *
- */
-
-#pragma once
-#ifndef WIIMOTE__WIIMOTE_CONTROLLER_HPP_
-#define WIIMOTE__WIIMOTE_CONTROLLER_HPP_
-
-#include <rclcpp/rclcpp.hpp>
-#include <rclcpp_lifecycle/lifecycle_node.hpp>
-#include <sensor_msgs/msg/imu.hpp>
-#include <sensor_msgs/msg/joy.hpp>
-#include <sensor_msgs/msg/joy_feedback_array.hpp>
-#include <std_msgs/msg/bool.hpp>
-#include <std_srvs/srv/empty.hpp>
-#include <wiimote_msgs/msg/state.hpp>
-
-#include "bluetooth/bluetooth.h"
-namespace wiimote_c
-{
-#include "cwiid.h"  // NOLINT, cpplint wants us to have a directory
-}
-
-#include "wiimote/stat_vector_3d.hpp"
-
-#define zeroedByCal(raw, zero, one) (((raw - zero) * 1.0) / ((one - zero) * 1.0))
-
-class WiimoteNode : public rclcpp_lifecycle::LifecycleNode
-{
-public:
-  /**
-   * \brief rclcpp component-compatible constructor
-   * \param options
-   */
-  explicit WiimoteNode(const rclcpp::NodeOptions & options);
-
-  CallbackReturn on_configure(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_activate(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_deactivate(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_cleanup(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_shutdown(const rclcpp_lifecycle::State & previous_state) override;
-  CallbackReturn on_error(const rclcpp_lifecycle::State & previous_state) override;
-
-  char * get_bluetooth_addr();
-  void set_bluetooth_addr(const char * bt_str);
-  bool pair_wiimote(int flags, int timeout);
-  int unpair_wiimote();
-
-  void publish();
-  bool wiimote_is_connected();
-  void check_connection();
-
-  void set_led_state(uint8_t led_state);
-  void set_rumble_state(uint8_t rumble);
-
-private:
-  void set_report_mode(uint8_t rpt_mode);
-  void check_factory_calibration_data();
-  void reset_motion_plus_state();
-  void reset_nunchuck_state();
-  void reset_classic_state();
-
-  static wiimote_c::cwiid_err_t cwiid_error_callback;
-
-  /**
-    Node [/wiimote_controller]
-    Publications:
-     * /joy [sensor_msgs/Joy]
-     * /wiimote/state [wiimote/State]
-     * /wiimote/nunchuk [sensor_msgs/Joy]
-     * /wiimote/classic [sensor_msgs/Joy]
-     * /imu/is_calibrated [std_msgs/Bool]
-     * /imu/data [sensor_msgs/Imu]
-
-    Subscriptions:
-     * /joy/set_feedback [sensor_msgs/JoyFeedbackArray]
-
-    Services:
-     * /imu/calibrate
-  **/
-  void joy_set_feedback_callback(sensor_msgs::msg::JoyFeedbackArray::ConstSharedPtr feedback);
-  bool service_imu_calibrate_callback(
-    std_srvs::srv::Empty::Request::SharedPtr, std_srvs::srv::Empty::Response::SharedPtr);
-
-  bool is_collecting_wiimote();
-  bool is_collecting_nunchuk();
-  bool is_collecting_classic();
-  bool is_collecting_motionplus();
-
-  bool is_present_nunchuk();
-  bool is_present_classic();
-  bool is_present_motionplus();
-
-  bool calibrate_joystick(uint8_t * stick, uint8_t(&center)[2], const char * name);
-  void update_joystick_min_max(
-    uint8_t * stick, uint8_t(&stick_min)[2], uint8_t(&stick_max)[2], const char * name);
-  void calculate_joystick_axis_xy(
-    uint8_t * stick_current, uint8_t * stick_min, uint8_t * stick_max, uint8_t * stick_center,
-    double (& stick)[2]);
-
-  void publish_joy();
-  void publish_imu_data();
-  void publish_wiimote_state();
-  bool publish_wiimote_nunchuk_common();
-  void publish_wiimote_nunchuk();
-  void publish_wiimote_classic();
-
-  void initialize_wiimote_state();
-  bool get_state_sample();
-
-  void set_led_bit(uint8_t led, bool on);
-  void set_rumble_bit(bool on);
-
-  rclcpp::Logger logger_;
-
-  rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Joy>::SharedPtr joy_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Imu>::SharedPtr imu_data_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<wiimote_msgs::msg::State>::SharedPtr wiimote_state_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Joy>::SharedPtr wiimote_nunchuk_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<sensor_msgs::msg::Joy>::SharedPtr wiimote_classic_pub_;
-  rclcpp_lifecycle::LifecyclePublisher<std_msgs::msg::Bool>::SharedPtr imu_is_calibrated_pub_;
-
-  rclcpp::Subscription<sensor_msgs::msg::JoyFeedbackArray>::SharedPtr joy_set_feedback_sub_;
-
-  rclcpp::Service<std_srvs::srv::Empty>::SharedPtr imu_calibrate_srv_;
-
-  rclcpp::TimerBase::SharedPtr check_connection_timer_;
-  rclcpp::TimerBase::SharedPtr publish_timer_;
-
-  // bluetooth device address
-  bdaddr_t bt_device_addr_;
-
-  // wiimote handle
-  wiimote_c::cwiid_wiimote_t * wiimote_;
-
-  // Last state of the Wiimote
-  struct wiimote_c::cwiid_state wiimote_state_;
-  // Time last state sample was taken
-  uint32_t state_secs_;
-  uint32_t state_nsecs_;
-
-  // Which data items should be reported in state
-  uint8_t report_mode_;
-
-  // Calibration status Wiimote
-  struct wiimote_c::acc_cal wiimote_cal_;  // wiimote acceleration factory calibration
-  bool wiimote_calibrated_;
-
-  rclcpp::Time calibration_time_;
-
-  // Joystick related constants
-  const uint8_t JOYSTICK_NUNCHUK_DEFAULT_CENTER_ = 127;  // Theoretical center
-  const uint8_t JOYSTICK_NUNCHUK_20PERCENT_MAX_ = 205;
-  const uint8_t JOYSTICK_NUNCHUK_20PERCENT_MIN_ = 50;
-  const uint8_t JOYSTICK_CLASSIC_LEFT_DEFAULT_CENTER_ = 31;  // Theoretical center
-  const uint8_t JOYSTICK_CLASSIC_LEFT_20PERCENT_MAX_ = 50;
-  const uint8_t JOYSTICK_CLASSIC_LEFT_20PERCENT_MIN_ = 13;
-  const uint8_t JOYSTICK_CLASSIC_RIGHT_DEFAULT_CENTER_ = 15;  // Theoretical center
-  const uint8_t JOYSTICK_CLASSIC_RIGHT_20PERCENT_MAX_ = 25;
-  const uint8_t JOYSTICK_CLASSIC_RIGHT_20PERCENT_MIN_ = 6;
-
-  // Calibration status Nunchuk
-  struct wiimote_c::acc_cal nunchuk_cal_;  // nunchuk acceleration factory calibration
-  bool nunchuk_calibrated_;
-  bool nunchuk_failed_calibration_;
-  uint8_t nunchuk_stick_center_[2];  // nunchuk stick center position
-  bool nunchuk_stick_calibrated_;
-  uint8_t nunchuk_stick_max_[2];  // Maximums x,y
-  uint8_t nunchuk_stick_min_[2];  // Minimums x,y
-
-  // Calibration status Classic Controller
-  uint8_t classic_stick_left_center_[2];  // nunchuk stick center position
-  bool classic_stick_left_calibrated_;
-  uint8_t classic_stick_left_max_[2];
-  uint8_t classic_stick_left_min_[2];
-  uint8_t classic_stick_right_center_[2];  // nunchuk stick center position
-  bool classic_stick_right_calibrated_;
-  uint8_t classic_stick_right_max_[2];
-  uint8_t classic_stick_right_min_[2];
-
-  const int IGNORE_DATA_POINTS_ = 100;  // throw away the first few data points
-  const int COVARIANCE_DATA_POINTS_ = 100;
-  StatVector3d linear_acceleration_stat_;
-  StatVector3d angular_velocity_stat_;
-  std::array<double, 9> linear_acceleration_covariance_;
-  std::array<double, 9> angular_velocity_covariance_;
-
-  uint8_t led_state_ = 0;
-  uint8_t rumble_ = 0;
-
-  uint64_t wiimote_errors = 0;
-
-  // Convert wiimote accelerator readings from g's to m/sec^2:
-  const double EARTH_GRAVITY_ = 9.80665;  // m/sec^2 @sea_level
-
-  // Method used in Wiimote Python version
-  // TODO(mdhorn): Repeat experiment or create a new one
-  // and collect data from multiple wiimotes and use mean.
-  //
-  // Turning wiimote gyro readings to radians/sec.
-  // This scale factor is highly approximate. Procedure:
-  //    - Tape Wiimote to center of an office chair seat
-  //    - Rotate the chair at approximately constant speed
-  //      for 10 seconds. This resulted in 6 chair revolutions
-  //    - On average, the Wiimote gyro read 3570 during this
-  //      experiment.
-  //    - Speed of chair revolving:
-  //         * One full circle is: 2#pi radians
-  //         * Six revolutions = 12pi radians. ==> 12pi rad in 10 sec ==> 1.2pi rad/sec
-  //         * => 3570 == 1.2pi
-  //         * => x*3570 = 1.2pi
-  //         * => x = 1.2pi/3570 (1.2pi = 3.769908)
-  //         * => scale factor = 0.001055997
-  // So multiplying the gyro readings by this factor
-  // calibrates the readings to show angular velocity
-  // in radians/sec.
-  const double GYRO_SCALE_FACTOR_ = 0.001055997;
-};
-
-#endif  // WIIMOTE__WIIMOTE_CONTROLLER_HPP_
diff --git a/wiimote/launch/feedback_test.launch.py b/wiimote/launch/feedback_test.launch.py
deleted file mode 100644
index 739db94..0000000
--- a/wiimote/launch/feedback_test.launch.py
+++ /dev/null
@@ -1,81 +0,0 @@
-# Copyright 2020 Intel Corporation
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-
-import launch
-import launch_ros
-from launch_ros.substitutions import FindPackageShare
-import lifecycle_msgs.msg
-
-
-def generate_launch_description():
-    wiimote_node = launch_ros.actions.LifecycleNode(
-        package='wiimote',
-        executable='wiimote_node',
-        namespace='',
-        name='wiimote',
-        output='screen',
-        parameters=[
-            FindPackageShare('wiimote').find('wiimote') + '/config/wiimote_params.yaml'
-        ]
-    )
-
-    configure_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE
-    ))
-
-    activate_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE
-    ))
-
-    on_configure_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=wiimote_node,
-            start_state='configuring',
-            goal_state='inactive',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='wiimote successfully configured. Proceeding to activate.'),
-                activate_wiimote,
-                launch.actions.LogInfo(msg='Launching feedbackTester node'),
-                launch_ros.actions.Node(
-                    package='wiimote',
-                    executable='feedback_tester.py',
-                    namespace='',
-                    name='feedbackTester',
-                    output='screen'
-                )
-            ]
-        ))
-
-    on_finalized_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=wiimote_node,
-            goal_state='finalized',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='wiimote node shutdown. Shutting down entire launch process'),
-                launch.actions.Shutdown(reason='wiimote node was shutdown')
-            ]
-        )
-    )
-
-    return launch.LaunchDescription(
-        [launch.actions.DeclareLaunchArgument(name='emulate_tty', default_value='True'),
-         wiimote_node,
-         configure_wiimote,
-         on_configure_wiimote,
-         on_finalized_wiimote])
diff --git a/wiimote/launch/turtlesim.launch.py b/wiimote/launch/turtlesim.launch.py
deleted file mode 100644
index c36145d..0000000
--- a/wiimote/launch/turtlesim.launch.py
+++ /dev/null
@@ -1,122 +0,0 @@
-# Copyright 2020 Intel Corporation
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-
-import launch
-import launch_ros
-from launch_ros.substitutions import FindPackageShare
-import lifecycle_msgs.msg
-
-
-def generate_launch_description():
-    wiimote_node = launch_ros.actions.LifecycleNode(
-        package='wiimote',
-        executable='wiimote_node',
-        namespace='',
-        name='wiimote',
-        output='screen',
-        parameters=[
-            FindPackageShare('wiimote').find('wiimote') + '/config/wiimote_params.yaml'
-        ]
-    )
-    configure_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE
-    ))
-
-    activate_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE
-    ))
-
-    teleop_wiimote_node = launch_ros.actions.LifecycleNode(
-        package='wiimote',
-        executable='teleop_wiimote_node',
-        namespace='',
-        name='teleop_wiimote',
-        output='screen',
-        remappings=[
-            ('/cmd_vel', 'turtle1/cmd_vel')
-        ],
-        parameters=[
-            FindPackageShare('wiimote').find('wiimote') + '/config/teleop_wiimote_params.yaml'
-        ]
-    )
-
-    configure_teleop_wiimote = launch.actions.EmitEvent(
-        event=launch_ros.events.lifecycle.ChangeState(
-            lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name(
-                '/teleop_wiimote'),
-            transition_id=lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE
-        ))
-
-    activate_teleop_wiimote = launch.actions.EmitEvent(
-        event=launch_ros.events.lifecycle.ChangeState(
-            lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name(
-                '/teleop_wiimote'),
-            transition_id=lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE
-        ))
-
-    turtle_sim_node = launch_ros.actions.Node(package='turtlesim',
-                                              executable='turtlesim_node',
-                                              name='turtle1')
-
-    on_configure_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=wiimote_node,
-            start_state='configuring',
-            goal_state='inactive',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='wiimote successfully configured. '
-                        'Proceeding to configure teleop_wiimote.'),
-                configure_teleop_wiimote,
-            ]
-        ))
-
-    on_configure_teleop_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=teleop_wiimote_node,
-            start_state='configuring',
-            goal_state='inactive',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='teleop_wiimote configured. Proceeding to activate both nodes.'),
-                activate_wiimote,
-                activate_teleop_wiimote,
-                launch.actions.LogInfo(msg='Starting turtlesim,'),
-                turtle_sim_node
-            ]
-        ))
-
-    on_finalized_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=wiimote_node,
-            goal_state='finalized',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='wiimote node shutdown. Shutting down entire launch process'),
-                launch.actions.Shutdown(reason='wiimote node was shutdown')
-            ]
-        )
-    )
-
-    return launch.LaunchDescription(
-        [launch.actions.DeclareLaunchArgument(name='emulate_tty', default_value='True'),
-         wiimote_node,
-         teleop_wiimote_node,
-         configure_wiimote,
-         on_configure_wiimote,
-         on_configure_teleop_wiimote,
-         on_finalized_wiimote])
diff --git a/wiimote/launch/wiimote_lifecycle.launch.py b/wiimote/launch/wiimote_lifecycle.launch.py
deleted file mode 100644
index 9ceb2ac..0000000
--- a/wiimote/launch/wiimote_lifecycle.launch.py
+++ /dev/null
@@ -1,73 +0,0 @@
-# Copyright 2020 Intel Corporation
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-
-import launch
-from launch.conditions import IfCondition, UnlessCondition
-from launch.substitutions import LaunchConfiguration, PythonExpression
-
-import launch_ros
-from launch_ros.substitutions import FindPackageShare
-
-import lifecycle_msgs.msg
-
-
-def generate_launch_description():
-    wiimote_node_name = 'wiimote'
-    wiimote_node = launch_ros.actions.LifecycleNode(
-        package='wiimote',
-        executable='wiimote_node',
-        namespace='',
-        name=wiimote_node_name,
-        output='screen',
-        parameters=[
-            FindPackageShare('wiimote').find('wiimote') + '/config/wiimote_params.yaml'
-        ]
-    )
-
-    configure_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_CONFIGURE
-    ), condition=UnlessCondition(
-        PythonExpression(["'", LaunchConfiguration('state'), "'=='unconfigured'"])))
-
-    activate_wiimote = launch.actions.EmitEvent(event=launch_ros.events.lifecycle.ChangeState(
-        lifecycle_node_matcher=launch_ros.events.lifecycle.matches_node_name('/wiimote'),
-        transition_id=lifecycle_msgs.msg.Transition.TRANSITION_ACTIVATE
-    ))
-
-    on_configure_wiimote = launch.actions.RegisterEventHandler(
-        launch_ros.event_handlers.OnStateTransition(
-            target_lifecycle_node=wiimote_node,
-            start_state='configuring',
-            goal_state='inactive',
-            entities=[
-                launch.actions.LogInfo(
-                    msg='wiimote successfully configured. Proceeding to activate.'),
-                activate_wiimote
-            ]
-        ),
-        condition=IfCondition(
-            PythonExpression(["'", LaunchConfiguration('state'), "'=='active'"])))
-
-    return launch.LaunchDescription([
-        launch.actions.DeclareLaunchArgument(name='emulate_tty', default_value='True'),
-        launch.actions.DeclareLaunchArgument(
-            name='state',
-            default_value='active',
-            description='Lifecycle state to trigger transition to. Supported: [unconfigured, '
-                        'inactive, active]'),
-        wiimote_node,
-        configure_wiimote,
-        on_configure_wiimote])
diff --git a/wiimote/nodes/feedback_tester.py b/wiimote/nodes/feedback_tester.py
deleted file mode 100755
index 078e000..0000000
--- a/wiimote/nodes/feedback_tester.py
+++ /dev/null
@@ -1,134 +0,0 @@
-#!/usr/bin/env python3
-
-# Copyright 2020 Intel Corporation
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-
-import time
-
-import rclpy
-import rclpy.exceptions
-from sensor_msgs.msg import JoyFeedback, JoyFeedbackArray
-
-INTER_PATTERN_SLEEP_DURATION = 0.2
-
-
-def main(args=None):
-    rclpy.init(args=args)
-
-    node = rclpy.create_node(node_name='ledControlTester')
-    pub = node.create_publisher(msg_type=JoyFeedbackArray, topic='/joy/set_feedback',
-                                qos_profile=1)
-
-    led0 = JoyFeedback()
-    led0.type = JoyFeedback.TYPE_LED
-    led0.id = 0
-    led1 = JoyFeedback()
-    led1.type = JoyFeedback.TYPE_LED
-    led1.id = 1
-    led2 = JoyFeedback()
-    led2.type = JoyFeedback.TYPE_LED
-    led2.id = 2
-    led3 = JoyFeedback()
-    led3.type = JoyFeedback.TYPE_LED
-    led3.id = 3
-    rum = JoyFeedback()
-    rum.type = JoyFeedback.TYPE_RUMBLE
-    rum.id = 0
-
-    while rclpy.ok():
-        msg = JoyFeedbackArray()
-        msg.array = [led0, led1, led2, led3, rum]
-
-        led0.intensity = 0.2
-        led3.intensity = 0.2
-        rum.intensity = 0.49
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led0.intensity = 1.0
-        rum.intensity = 0.51
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led0.intensity = 0.0
-        led1.intensity = 1.0
-        rum.intensity = 0.0
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led1.intensity = 0.0
-        led2.intensity = 1.0
-        rum.intensity = 0.7
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led2.intensity = 0.0
-        led3.intensity = 1.0
-        rum.intensity = 0.49
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led1.intensity = 1.0
-        led2.intensity = 1.0
-        rum.intensity = 1.0
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-        led0.intensity = 1.0
-        led1.intensity = 0.4
-        led2.intensity = 0.4
-
-        msg.array = [led0, led1, led2]
-
-        if msg is not None:
-            node.get_logger().debug('Msg: ' + str(msg))
-            pub.publish(msg)
-            time.sleep(INTER_PATTERN_SLEEP_DURATION)
-
-
-if __name__ == '__main__':
-
-    print('\n   ****************************************************************\n')
-    print('****     You should see six LED on/off configurations, and feel Rumbles!  ****')
-    print('\n   **************************************************************')
-    print('[off, off, off, off]')
-    print('[on,  off, off, off]')
-    print('[off, on,  off, off]')
-    print('[off, off, on,  off]')
-    print('[off, off, off, on ]')
-    print('[off, on,  on,  on ]')
-    print('[on,  off, off, on ]')
-    try:
-        main()
-    except rclpy.exceptions.ROSInterruptException:
-        pass
diff --git a/wiimote/package.xml b/wiimote/package.xml
deleted file mode 100644
index 27c2cbb..0000000
--- a/wiimote/package.xml
+++ /dev/null
@@ -1,54 +0,0 @@
-<?xml version="1.0"?>
-<?xml-model
-    href="http://download.ros.org/schema/package_format3.xsd"
-    schematypens="http://www.w3.org/2001/XMLSchema"?>
-<package format="3">
-  <name>wiimote</name>
-  <version>3.1.0</version>
-  <description>
-    The wiimote package allows ROS nodes to communicate with a Nintendo Wiimote
-    and its related peripherals, including the Nunchuk, Motion Plus, and
-    (experimentally) the Classic. The package implements a ROS node that uses
-    Bluetooth to communicate with the Wiimote device, obtaining accelerometer
-    and gyro data, the state of LEDs, the IR camera, rumble (vibrator),
-    buttons, joystick, and battery state. The node additionally enables ROS
-    nodes to control the Wiimote's LEDs and vibration for feedback to the human
-    Wiimote operator. LEDs and vibration may be switched on and off, or made to
-    operate according to a timed pattern.
-  </description>
-  <maintainer email="jbo@jhu.edu">Jonathan Bohren</maintainer>
-  <license>GPL</license>
-
-  <url type="website">http://www.ros.org/wiki/wiimote</url>
-  <url type="repository">https://github.com/ros-drivers/joystick_drivers</url>
-  <url type="bugtracker">https://github.com/ros-drivers/joystick_drivers/issues</url>
-
-  <author>Andreas Paepcke</author>
-  <author>Melonee Wise</author>
-  <author email="mark.d.horn@intel.com">Mark Horn</author>
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-  <buildtool_depend>ament_cmake_auto</buildtool_depend>
-
-  <build_depend>libbluetooth-dev</build_depend>
-  <exec_depend>libbluetooth</exec_depend>
-  <build_depend>cwiid-dev</build_depend>
-  <exec_depend>cwiid</exec_depend>
-
-  <depend>geometry_msgs</depend>
-  <depend>rclcpp</depend>
-  <depend>rclcpp_components</depend>
-  <depend>rclcpp_lifecycle</depend>
-  <depend>sensor_msgs</depend>
-  <depend>std_msgs</depend>
-  <depend>std_srvs</depend>
-  <depend>wiimote_msgs</depend>
-
-  <test_depend>ament_cmake_gtest</test_depend>
-  <test_depend>ament_lint_auto</test_depend>
-  <test_depend>ament_lint_common</test_depend>
-
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
diff --git a/wiimote/src/gpl-2.0.txt b/wiimote/src/gpl-2.0.txt
deleted file mode 100644
index d159169..0000000
--- a/wiimote/src/gpl-2.0.txt
+++ /dev/null
@@ -1,339 +0,0 @@
-                    GNU GENERAL PUBLIC LICENSE
-                       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
- 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-                            Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Lesser General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-                    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-                            NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-                     END OF TERMS AND CONDITIONS
-
-            How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the "copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the program's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License along
-    with this program; if not, write to the Free Software Foundation, Inc.,
-    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) year name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Lesser General
-Public License instead of this License.
diff --git a/wiimote/src/stat_vector_3d.cpp b/wiimote/src/stat_vector_3d.cpp
deleted file mode 100644
index cfe8dee..0000000
--- a/wiimote/src/stat_vector_3d.cpp
+++ /dev/null
@@ -1,165 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * Three dimensional statistic vector for use with the
- * for ROS Node which interfaces with a wiimote control unit.
- */
-
-/*
- * Initial C++ implementation by
- *   Mark Horn <mark.d.horn@intel.com>
- *
- * Revisions:
- *
- */
-
-#include "wiimote/stat_vector_3d.hpp"
-
-
-#include <algorithm>
-#include <cmath>
-#include <functional>
-#include <numeric>
-#include <stdexcept>
-
-StatVector3d::StatVector3d() {count_ = 0;}
-
-StatVector3d::StatVector3d(int x, int y, int z)
-{
-  count_ = 0;
-
-  addData(x, y, z);
-}
-
-void StatVector3d::clear()
-{
-  x_.clear();
-  y_.clear();
-  z_.clear();
-
-  count_ = 0;
-}
-
-int StatVector3d::size() {return count_;}
-
-void StatVector3d::addData(int x, int y, int z)
-{
-  ++count_;
-
-  x_.push_back(x);
-  y_.push_back(y);
-  z_.push_back(z);
-}
-
-TVectorDouble StatVector3d::getMeanRaw()
-{
-  TVectorDouble result;
-
-  if (x_.size() < 1) {
-    throw std::runtime_error("Not enough data points for calculations");
-  }
-
-  double x_sum = std::accumulate(std::begin(x_), std::end(x_), 0.0);
-  result.push_back(x_sum / x_.size());
-
-  double y_sum = std::accumulate(std::begin(y_), std::end(y_), 0.0);
-  result.push_back(y_sum / y_.size());
-
-  double z_sum = std::accumulate(std::begin(z_), std::end(z_), 0.0);
-  result.push_back(z_sum / z_.size());
-
-  return result;
-}
-
-TVectorDouble StatVector3d::getMeanScaled(double scale)
-{
-  TVectorDouble mean = getMeanRaw();
-
-  std::transform(
-    mean.begin(), mean.end(), mean.begin(), std::bind1st(std::multiplies<double>(), scale));
-
-  return mean;
-}
-
-TVectorDouble StatVector3d::getVarianceRaw()
-{
-  TVectorDouble result;
-
-  TVectorDouble mean = getMeanRaw();
-
-  if (x_.size() < 2) {
-    throw std::runtime_error("Not enough data points for calculations");
-  }
-
-  double accum = 0.0;
-  std::for_each(
-    std::begin(x_), std::end(x_),
-    [&](const double d)
-    {accum += (d - mean.at(0)) * (d - mean.at(0));});
-
-  result.push_back(accum / (x_.size() - 1));
-
-  accum = 0.0;
-  std::for_each(
-    std::begin(y_), std::end(y_),
-    [&](const double d)
-    {accum += (d - mean.at(1)) * (d - mean.at(1));});
-
-  result.push_back(accum / (y_.size() - 1));
-
-  accum = 0.0;
-  std::for_each(
-    std::begin(z_), std::end(z_),
-    [&](const double d)
-    {accum += (d - mean.at(2)) * (d - mean.at(2));});
-
-  result.push_back(accum / (z_.size() - 1));
-
-  return result;
-}
-
-TVectorDouble StatVector3d::getVarianceScaled(double scale)
-{
-  TVectorDouble variance = getVarianceRaw();
-
-  std::transform(
-    variance.begin(), variance.end(), variance.begin(),
-    std::bind1st(std::multiplies<double>(), scale));
-
-  return variance;
-}
-
-TVectorDouble StatVector3d::getStandardDeviationRaw()
-{
-  TVectorDouble result;
-
-  TVectorDouble variance = getVarianceRaw();
-
-  result.push_back(sqrt(variance.at(0)));
-  result.push_back(sqrt(variance.at(1)));
-  result.push_back(sqrt(variance.at(2)));
-
-  return result;
-}
-
-TVectorDouble StatVector3d::getStandardDeviationScaled(double scale)
-{
-  TVectorDouble stddev = getStandardDeviationRaw();
-
-  std::transform(
-    stddev.begin(), stddev.end(), stddev.begin(), std::bind1st(std::multiplies<double>(), scale));
-
-  return stddev;
-}
diff --git a/wiimote/src/teleop_wiimote.cpp b/wiimote/src/teleop_wiimote.cpp
deleted file mode 100644
index 50a91db..0000000
--- a/wiimote/src/teleop_wiimote.cpp
+++ /dev/null
@@ -1,565 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * ROS Node for using a wiimote control unit to direct a robot.
- */
-
-#include "wiimote/teleop_wiimote.hpp"
-
-#include <cmath>
-
-namespace
-{
-// Sane defaults based on the TurtleBot
-// TurtleBot maximum speed documented at 25.6"/second ~= 0.65024 m/s
-constexpr double kDefaultMaxLinearX = 0.65024;  // m/s
-// TurtleBot maximum angular speed is documented at 180 degrees Pi / second
-constexpr double kDefaultMaxAngularZ = M_PI;  // rad/s
-
-constexpr double kDefaultPercentLinearThrottle = 0.75;   // decimal
-constexpr double kDefaultPercentAngularThrottle = 0.75;  // decimal
-}  // namespace
-
-TeleopWiimote::TeleopWiimote(const rclcpp::NodeOptions & options)
-: rclcpp_lifecycle::LifecycleNode("teleop_wiimote", options), logger_(get_logger())
-{
-  RCLCPP_INFO(logger_, "TeleopWiimote lifecycle node created.");
-  auto linear_x_max_vel_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  linear_x_max_vel_param_desc.name = "linear.x.max_velocity";
-  linear_x_max_vel_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  linear_x_max_vel_param_desc.description = "Maximum linear velocity in m/s";
-  declare_parameter("linear.x.max_velocity", kDefaultMaxLinearX, linear_x_max_vel_param_desc);
-
-  auto linear_x_min_vel_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  linear_x_min_vel_param_desc.name = "linear.x.min_velocity";
-  linear_x_min_vel_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  linear_x_min_vel_param_desc.description = "Minimum linear velocity in m/s";
-  declare_parameter("linear.x.min_velocity", -kDefaultMaxLinearX, linear_x_min_vel_param_desc);
-
-  auto angular_z_max_vel_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  angular_z_max_vel_param_desc.name = "angular.z.max_velocity";
-  angular_z_max_vel_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  angular_z_max_vel_param_desc.description = "Maximum angular velocity in rad/s";
-  declare_parameter("angular.z.max_velocity", kDefaultMaxAngularZ, angular_z_max_vel_param_desc);
-
-  auto angular_z_min_vel_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  angular_z_min_vel_param_desc.name = "angular.z.min_velocity";
-  angular_z_min_vel_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  angular_z_min_vel_param_desc.description = "Minimum angular velocity in rad/s";
-  declare_parameter("angular.z.min_velocity", -kDefaultMaxAngularZ, angular_z_min_vel_param_desc);
-
-  auto linear_x_throttle_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  linear_x_throttle_param_desc.name = "linear.x.throttle_percent";
-  linear_x_throttle_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  linear_x_throttle_param_desc.description = "Linear x throttle percentage in decimal";
-  declare_parameter(
-    "linear.x.throttle_percent", kDefaultPercentLinearThrottle, linear_x_throttle_param_desc);
-
-  auto angular_z_throttle_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  angular_z_throttle_param_desc.name = "angular.z.throttle_percent";
-  angular_z_throttle_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  angular_z_throttle_param_desc.description = "Angular z throttle percentage in decimal";
-  declare_parameter("angular.z.throttle_percent", kDefaultPercentAngularThrottle);
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
-TeleopWiimote::on_configure(const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Configuring: started");
-  // ROS2 resources
-  vel_pub_ = create_publisher<geometry_msgs::msg::Twist>("cmd_vel", 3);
-  joy_pub_ = create_publisher<sensor_msgs::msg::JoyFeedbackArray>("joy/set_feedback", 3);
-  joy_sub_ = create_subscription<sensor_msgs::msg::Joy>(
-    "wiimote/nunchuk", 10,
-    [this](sensor_msgs::msg::Joy::ConstSharedPtr joy) {this->joy_callback(joy);});
-  wiimote_sub_ = create_subscription<wiimote_msgs::msg::State>(
-    "wiimote/state", 10, [this](wiimote_msgs::msg::State::ConstSharedPtr wiistate) {
-      this->wiimote_state_callback(wiistate);
-    });
-
-  linear_x_max_velocity_ = get_parameter("linear.x.max_velocity").as_double();
-  linear_x_min_velocity_ = get_parameter("linear.x.min_velocity").as_double();
-  angular_z_max_velocity_ = get_parameter("angular.z.max_velocity").as_double();
-  angular_z_min_velocity_ = get_parameter("angular.z.min_velocity").as_double();
-  percent_linear_throttle_ = get_parameter("linear.x.throttle_percent").as_double();
-  percent_angular_throttle_ = get_parameter("angular.z.throttle_percent").as_double();
-
-  dpad_in_use_ = false;
-  njoy_in_use_ = false;
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
-TeleopWiimote::on_activate(const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Activating");
-  RCLCPP_INFO(logger_, "Updating configuration variables with latest parameters");
-  auto val = get_parameter("linear.x.max_velocity").as_double();
-  if (linear_x_max_velocity_ != val) {
-    RCLCPP_INFO(
-      logger_, "linear.x.max_velocity updated. From: %3.0f, To: %3.0f", linear_x_max_velocity_,
-      val);
-    linear_x_max_velocity_ = val;
-  }
-
-  val = get_parameter("linear.x.min_velocity").as_double();
-  if (linear_x_min_velocity_ != val) {
-    RCLCPP_INFO(
-      logger_, "linear.x.min_velocity updated. From: %3.0f, To: %3.0f", linear_x_min_velocity_,
-      val);
-    linear_x_min_velocity_ = val;
-  }
-
-  val = get_parameter("angular.z.max_velocity").as_double();
-  if (angular_z_max_velocity_ != val) {
-    RCLCPP_INFO(
-      logger_, "angular.z.max_velocity updated. From: %3.0f, To: %3.0f", angular_z_max_velocity_,
-      val);
-    angular_z_max_velocity_ = val;
-  }
-
-  val = get_parameter("angular.z.min_velocity").as_double();
-  if (angular_z_min_velocity_ != val) {
-    RCLCPP_INFO(
-      logger_, "angular.z.min_velocity updated. From: %3.0f, To: %3.0f", angular_z_min_velocity_,
-      val);
-    angular_z_min_velocity_ = val;
-  }
-
-  val = get_parameter("linear.x.throttle_percent").as_double();
-  if (percent_linear_throttle_ != val) {
-    RCLCPP_INFO(
-      logger_, "linear.x.throttle_percent updated. From: %3.0f, To: %3.0f",
-      percent_linear_throttle_, val);
-    percent_linear_throttle_ = val;
-  }
-
-  val = get_parameter("angular.z.throttle_percent").as_double();
-  if (percent_angular_throttle_ != val) {
-    RCLCPP_INFO(
-      logger_, "angular.z.throttle_percent updated. From: %3.0f, To: %3.0f",
-      percent_angular_throttle_, val);
-    percent_angular_throttle_ = val;
-  }
-
-  // Activate lifecycle publishers
-  vel_pub_->on_activate();
-  joy_pub_->on_activate();
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
-TeleopWiimote::on_deactivate(const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Deactivating");
-  vel_pub_->on_deactivate();
-  joy_pub_->on_deactivate();
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn TeleopWiimote::on_cleanup(
-  const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Cleaning Up");
-  vel_pub_.reset();
-  joy_pub_.reset();
-  joy_sub_.reset();
-  wiimote_sub_.reset();
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
-TeleopWiimote::on_shutdown(const rclcpp_lifecycle::State & previous_state)
-{
-  RCLCPP_INFO(
-    logger_, "Shutting Down. Previous State: %s, id: %d", previous_state.label().c_str(),
-    previous_state.id());
-
-  // Nothing to do if unconfigured
-  if (previous_state.id() == 1) {
-    return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-  }
-
-  vel_pub_.reset();
-  joy_pub_.reset();
-  joy_sub_.reset();
-  wiimote_sub_.reset();
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn TeleopWiimote::on_error(
-  const rclcpp_lifecycle::State & previous_state)
-{
-  RCLCPP_INFO(
-    logger_, "Error handling WiimoteNode. Previous State: %s, id: %d",
-    previous_state.label().c_str(), previous_state.id());
-  return LifecycleNodeInterface::CallbackReturn::FAILURE;
-}
-
-void TeleopWiimote::set_led_feedback(double value)
-{
-  sensor_msgs::msg::JoyFeedbackArray joy_feedback_array;
-  sensor_msgs::msg::JoyFeedback fb_led0;
-  sensor_msgs::msg::JoyFeedback fb_led1;
-  sensor_msgs::msg::JoyFeedback fb_led2;
-  sensor_msgs::msg::JoyFeedback fb_led3;
-
-  fb_led0.type = sensor_msgs::msg::JoyFeedback::TYPE_LED;
-  fb_led0.id = 0;
-  fb_led0.intensity = 0.0;
-  fb_led1.type = sensor_msgs::msg::JoyFeedback::TYPE_LED;
-  fb_led1.id = 1;
-  fb_led1.intensity = 0.0;
-  fb_led2.type = sensor_msgs::msg::JoyFeedback::TYPE_LED;
-  fb_led2.id = 2;
-  fb_led2.intensity = 0.0;
-  fb_led3.type = sensor_msgs::msg::JoyFeedback::TYPE_LED;
-  fb_led3.id = 3;
-  fb_led3.intensity = 0.0;
-
-  if (value > 10.0) {
-    fb_led0.intensity = 1.0;
-  }
-  if (value > 35.0) {
-    fb_led1.intensity = 1.0;
-  }
-  if (value > 60.0) {
-    fb_led2.intensity = 1.0;
-  }
-  if (value > 85.0) {
-    fb_led3.intensity = 1.0;
-  }
-
-  joy_feedback_array.array.push_back(fb_led0);
-  joy_feedback_array.array.push_back(fb_led1);
-  joy_feedback_array.array.push_back(fb_led2);
-  joy_feedback_array.array.push_back(fb_led3);
-
-  joy_pub_->publish(joy_feedback_array);
-}
-
-void TeleopWiimote::rumble_feedback(std::chrono::milliseconds duration)
-{
-  sensor_msgs::msg::JoyFeedbackArray joy_feedback_array;
-  sensor_msgs::msg::JoyFeedback fb_rumble;
-
-  fb_rumble.type = sensor_msgs::msg::JoyFeedback::TYPE_RUMBLE;
-  fb_rumble.id = 0;
-
-  fb_rumble.intensity = 1.0;
-
-  joy_feedback_array.array.push_back(fb_rumble);
-
-  joy_pub_->publish(joy_feedback_array);
-  std::this_thread::sleep_for(duration);
-  fb_rumble.intensity = 0.0;
-
-  joy_feedback_array.array.push_back(fb_rumble);
-
-  joy_pub_->publish(joy_feedback_array);
-}
-
-void TeleopWiimote::joy_callback(const sensor_msgs::msg::Joy::ConstSharedPtr & joy)
-{
-  if (dpad_in_use_) {
-    return;
-  }
-
-  geometry_msgs::msg::Twist vel;
-
-  static constexpr int MSG_BTN_Z = 0;
-  static constexpr int MSG_BTN_C = 1;
-
-  double x = joy->axes[0];
-  double y = joy->axes[1];
-  static constexpr double abs_error = 0.000001;
-
-  if (fabs(x) > abs_error || fabs(y) > abs_error) {
-    njoy_in_use_ = true;
-
-    double boost = 1.0;
-
-    RCLCPP_DEBUG(logger_, "nunchuk: x: %f, y: %f", x, y);
-
-    if (joy->buttons[MSG_BTN_Z] || joy->buttons[MSG_BTN_C]) {
-      RCLCPP_DEBUG(
-        logger_, "buttons[]: Z: %d, C: %d", joy->buttons[MSG_BTN_Z], joy->buttons[MSG_BTN_C]);
-
-      // Z-Button is thrusters on!
-      if (joy->buttons[MSG_BTN_Z]) {
-        boost = 2.0;
-      }
-
-      // C-Button is easy does it.
-      if (joy->buttons[MSG_BTN_C]) {
-        boost = 0.25;
-      }
-    }
-
-    if (y >= 0.0) {
-      vel.linear.x = fmin(
-        (y * boost * (linear_x_max_velocity_ * percent_linear_throttle_)), linear_x_max_velocity_);
-
-      if (x >= 0.0) {
-        vel.angular.z = fmin(
-          (x * boost * (angular_z_max_velocity_ * percent_angular_throttle_)),
-          angular_z_max_velocity_);
-      } else {
-        vel.angular.z = fmax(
-          (fabs(x) * boost * (angular_z_min_velocity_ * percent_angular_throttle_)),
-          angular_z_min_velocity_);
-      }
-    } else {
-      vel.linear.x = fmax(
-        (fabs(y) * boost * (linear_x_min_velocity_ * percent_linear_throttle_)),
-        linear_x_min_velocity_);
-
-      if (x > 0.0) {
-        vel.angular.z = fmax(
-          (x * boost * (angular_z_min_velocity_ * percent_angular_throttle_)),
-          angular_z_min_velocity_);
-      } else {
-        vel.angular.z = fmin(
-          (fabs(x) * boost * (angular_z_max_velocity_ * percent_angular_throttle_)),
-          angular_z_max_velocity_);
-      }
-    }
-
-    // In order to spin-in-place left or right, we need full angular with NO linear component.
-    // To enable this, we will publish no linear motion if nunchuk joystick Y value is
-    // "really small" as the joy stick isn't 100 accurate.
-    if (fabs(y) < 0.01) {
-      vel.linear.x = 0;
-    }
-
-    vel_pub_->publish(vel);
-  } else {
-    if (njoy_in_use_) {
-      vel_pub_->publish(vel);
-
-      njoy_in_use_ = false;
-    }
-  }
-}
-
-void TeleopWiimote::wiimote_state_callback(
-  const wiimote_msgs::msg::State::ConstSharedPtr & wiistate)
-{
-  using namespace std::chrono_literals;
-
-  static constexpr int MSG_BTN_1 = 0;
-  static constexpr int MSG_BTN_2 = 1;
-  static constexpr int MSG_BTN_PLUS = 2;
-  static constexpr int MSG_BTN_MINUS = 3;
-  static constexpr int MSG_BTN_A = 4;
-  static constexpr int MSG_BTN_B = 5;
-  static constexpr int MSG_BTN_UP = 6;
-  static constexpr int MSG_BTN_DOWN = 7;
-  static constexpr int MSG_BTN_LEFT = 8;
-  static constexpr int MSG_BTN_RIGHT = 9;
-  static constexpr int MSG_BTN_HOME = 10;
-
-  static bool one_depressed = false;
-  static bool two_depressed = false;
-  static bool plus_depressed = false;
-  static bool minus_depressed = false;
-  static bool home_depressed = false;
-
-  // 1-Button used to set the amount of Linear Throttle
-  // Pressing the button show approx setting level on the
-  // Wiimote LEDs (see setLEDFeedback for levels).
-  // Wiimote uses a short Rumble when the minimum or
-  // maximum is reached.
-  // +-Button increases; --Button decreases while hold 1-Button
-  if (wiistate->buttons[MSG_BTN_1]) {
-    if (wiistate->buttons[MSG_BTN_PLUS]) {
-      if (!plus_depressed) {
-        percent_linear_throttle_ += 0.05;
-        if (percent_linear_throttle_ >= 1.0) {
-          rumble_feedback(100ms);
-        }
-        percent_linear_throttle_ = fmin(percent_linear_throttle_, 1.0);
-        plus_depressed = true;
-
-        set_led_feedback(percent_linear_throttle_ * 100.0);
-
-        set_parameter({"linear.x.throttle_percent", percent_linear_throttle_});
-        RCLCPP_INFO(logger_, "Linear X Throttle Percent: %3.0f", percent_linear_throttle_ * 100.0);
-      }
-    } else {
-      plus_depressed = false;
-
-      if (wiistate->buttons[MSG_BTN_MINUS]) {
-        if (!minus_depressed) {
-          percent_linear_throttle_ -= 0.05;
-          if (percent_linear_throttle_ <= 0.1) {
-            rumble_feedback(100ms);
-          }
-          percent_linear_throttle_ = fmax(percent_linear_throttle_, 0.1);
-          minus_depressed = true;
-
-          set_led_feedback(percent_linear_throttle_ * 100.0);
-
-          set_parameter({"linear.x.throttle_percent", percent_linear_throttle_});
-          RCLCPP_INFO(
-            logger_, "Linear X Throttle Percent: %3.0f", percent_linear_throttle_ * 100.0);
-        }
-      } else {
-        minus_depressed = false;
-      }
-    }
-
-    if (!one_depressed) {
-      set_led_feedback(percent_linear_throttle_ * 100.0);
-
-      set_parameter({"linear.x.throttle_percent", percent_linear_throttle_});
-      RCLCPP_INFO(logger_, "Linear X Throttle Percent: %3.0f", percent_linear_throttle_ * 100.0);
-
-      one_depressed = true;
-    }
-  } else if (wiistate->buttons[MSG_BTN_2]) {
-    // 2-Button used to set the amount of Angular Throttle
-    // Same function and feedbacks as 1-Button (see above)
-    if (wiistate->buttons[MSG_BTN_PLUS]) {
-      if (!plus_depressed) {
-        percent_angular_throttle_ += 0.05;
-        if (percent_angular_throttle_ >= 1.0) {
-          rumble_feedback(100ms);
-        }
-        percent_angular_throttle_ = fmin(percent_angular_throttle_, 1.0);
-        plus_depressed = true;
-
-        set_led_feedback(percent_angular_throttle_ * 100.0);
-
-        set_parameter({"angular.z.throttle_percent", percent_linear_throttle_});
-        RCLCPP_INFO(
-          logger_, "Angular Z Throttle Percent: %3.0f", percent_angular_throttle_ * 100.0);
-      }
-    } else {
-      plus_depressed = false;
-
-      if (wiistate->buttons[MSG_BTN_MINUS]) {
-        if (!minus_depressed) {
-          percent_angular_throttle_ -= 0.05;
-          if (percent_angular_throttle_ <= 0.1) {
-            rumble_feedback(100ms);
-          }
-          percent_angular_throttle_ = fmax(percent_angular_throttle_, 0.1);
-          minus_depressed = true;
-
-          set_led_feedback(percent_angular_throttle_ * 100.0);
-
-          set_parameter({"angular.z.throttle_percent", percent_linear_throttle_});
-          RCLCPP_INFO(
-            logger_, "Angular Z Throttle Percent: %3.0f", percent_angular_throttle_ * 100.0);
-        }
-      } else {
-        minus_depressed = false;
-      }
-    }
-
-    if (!two_depressed) {
-      set_led_feedback(percent_angular_throttle_ * 100.0);
-
-      set_parameter({"angular.z.throttle_percent", percent_linear_throttle_});
-      RCLCPP_INFO(logger_, "Angular Z Throttle Percent: %3.0f", percent_angular_throttle_ * 100.0);
-
-      two_depressed = true;
-    }
-  } else {
-    if (one_depressed || two_depressed) {
-      set_led_feedback(0.0);
-    }
-
-    one_depressed = false;
-    two_depressed = false;
-
-    // Home-Button used the Wiimote LEDs (see set_led_feedback for levels).
-    // to show the approx battery level of the Wiimote.
-    // Only works if the 1-Button or 2-Button are not in use.
-    if (wiistate->buttons[MSG_BTN_HOME]) {
-      if (!home_depressed) {
-        RCLCPP_INFO(
-          logger_, "Battery[]: raw: %f, percent: %f", wiistate->raw_battery,
-          wiistate->percent_battery);
-        set_led_feedback(wiistate->percent_battery);
-        home_depressed = true;
-      }
-    } else {
-      if (home_depressed) {
-        set_led_feedback(0.0);
-      }
-
-      home_depressed = false;
-    }
-  }
-
-  geometry_msgs::msg::Twist vel;
-
-  if (
-    !njoy_in_use_ && (wiistate->buttons[MSG_BTN_RIGHT] || wiistate->buttons[MSG_BTN_LEFT] ||
-    wiistate->buttons[MSG_BTN_UP] || wiistate->buttons[MSG_BTN_DOWN]))
-  {
-    dpad_in_use_ = true;
-
-    RCLCPP_DEBUG(
-      logger_, "buttons[]: Right: %d, Left: %d, Up: %d, Down: %d, A: %d, B: %d",
-      wiistate->buttons[MSG_BTN_RIGHT], wiistate->buttons[MSG_BTN_LEFT],
-      wiistate->buttons[MSG_BTN_UP], wiistate->buttons[MSG_BTN_DOWN], wiistate->buttons[MSG_BTN_A],
-      wiistate->buttons[MSG_BTN_B]);
-
-    double boost = 1.0;
-
-    // B-Button is thrusters on!
-    if (wiistate->buttons[MSG_BTN_B]) {
-      boost = 2.0;
-    }
-
-    // A-Button is easy does it.
-    if (wiistate->buttons[MSG_BTN_A]) {
-      boost = 0.25;
-    }
-
-    if (wiistate->buttons[MSG_BTN_UP]) {
-      vel.linear.x =
-        fmin((boost * (linear_x_max_velocity_ * percent_linear_throttle_)), linear_x_max_velocity_);
-    } else if (wiistate->buttons[MSG_BTN_DOWN]) {
-      vel.linear.x =
-        fmax((boost * (linear_x_min_velocity_ * percent_linear_throttle_)), linear_x_min_velocity_);
-    }
-
-    if (wiistate->buttons[MSG_BTN_LEFT]) {
-      vel.angular.z = fmin(
-        (boost * (angular_z_max_velocity_ * percent_angular_throttle_)), angular_z_max_velocity_);
-    } else if (wiistate->buttons[MSG_BTN_RIGHT]) {
-      vel.angular.z = fmax(
-        (boost * (angular_z_min_velocity_ * percent_angular_throttle_)), angular_z_min_velocity_);
-    }
-
-    vel_pub_->publish(vel);
-  } else {
-    if (dpad_in_use_) {
-      vel_pub_->publish(vel);
-      dpad_in_use_ = false;
-    }
-  }
-}
-// Register TeleopWiimote to ros2 components
-#include <rclcpp_components/register_node_macro.hpp> //NOLINT
-RCLCPP_COMPONENTS_REGISTER_NODE(TeleopWiimote)
diff --git a/wiimote/src/wiimote_controller.cpp b/wiimote/src/wiimote_controller.cpp
deleted file mode 100644
index e960895..0000000
--- a/wiimote/src/wiimote_controller.cpp
+++ /dev/null
@@ -1,1695 +0,0 @@
-// Copyright 2020 Intel Corporation
-// This program is free software: you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation, either version 3 of the License, or
-// (at your option) any later version.
-//
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-//
-// You should have received a copy of the GNU General Public License
-// along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-/*
- * ROS Node for interfacing with a wiimote control unit.
- */
-
-/*
- * This code is based on the original Python implementation
- * created by Andreas Paepcke and Melonee Wise
- *  Andreas Paepcke <paepcke@anw.willowgarage.com>
- * with contributions by
- *  David Lu <davidlu@wustl.edu>
- *  Miguel Angel Julian Aguilar <miguel.angel@thecorpora.com>
- * See https://github.com/ros-drivers/joystick_drivers/tree/indigo-devel/wiimote
- * for details and history.
- *
- * This C++ implementation used the functionality of the existing
- * Python code as the feature requirements.
- */
-
-/*
- * Initial C++ implementation by
- *   Mark Horn <mark.d.horn@intel.com>
- *
- * The C++ implementation was designed with focus on reduced resource consumption.
- *
- * Differences from Python implementation:
- * - Both "/wiimote/nunchuk" and "/wiimote/classic" topics are only published
- *   if the Nunchuk or Classic Controller are connected to the wiimote respectively.
- * - Wiimote data is only polled from the controller if the data is required
- *   to publish for a topic which has at least one subscriber.
- *
- * Revisions:
- *
- */
-#include "wiimote/wiimote_controller.hpp"
-
-#include <cmath>
-#include <functional>
-#include <vector>
-
-// Node Defaults
-namespace
-{
-constexpr auto kDefaultNodeName = "wiimote";
-constexpr auto kDefaultNamespace = "";
-
-// Topics Defaults
-constexpr auto kDefaultJoyTopicNm = "joy";
-constexpr auto kDefaultImuDataTopicNm = "imu/data";
-constexpr auto kDefaultImuIsCalibTopicNm = "imu/is_calibrated";
-constexpr auto kDefaultImuCalibSrvNm = "imu/calibrate";
-constexpr auto kDefaultWiimoteStateTopicNm = "wiimote/state";
-constexpr auto kDefaultWiimoteNunchukTopicNm = "wiimote/nunchuk";
-constexpr auto kDefaultWiimoteClassicTopicNm = "wiimote/classic";
-
-constexpr auto kDefaultSetFeedbackTopicNm = "joy/set_feedback";
-
-// Params Defaults
-constexpr auto kDefaultParamBluetoothAddrAny = "00:00:00:00:00:00";
-constexpr int kDefaultParamPairTimeoutIndefinitely = -1;
-constexpr double kDefaultParamCheckConnInterval = .5;
-constexpr double kDefaultParamPublishInterval = .1;
-constexpr bool kDefaultParamRequireMotionplus = false;
-constexpr bool kDefaultParamRequireNunchuk = false;
-constexpr bool kDefaultParamRequireClassic = false;
-}  // namespace
-
-WiimoteNode::WiimoteNode(const rclcpp::NodeOptions & options)
-: LifecycleNode(kDefaultNodeName, kDefaultNamespace, options), logger_(get_logger())
-{
-  auto bluetooth_addr_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  bluetooth_addr_param_desc.name = "bluetooth_addr";
-  bluetooth_addr_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_STRING;
-  bluetooth_addr_param_desc.description =
-    "Bluetooth address. Format: DD:DD:DD:DD:DD:DD. "
-    "Default value, 00:00:00:00:00:00, will pair to any found device.";
-  declare_parameter("bluetooth_addr", kDefaultParamBluetoothAddrAny, bluetooth_addr_param_desc);
-
-  auto pair_timeout_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  pair_timeout_param_desc.name = "pair_timeout";
-  pair_timeout_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_INTEGER;
-  pair_timeout_param_desc.description =
-    "Duration, in seconds, to wait for connecting device. "
-    "Default value, -1, will wait indefinitely.";
-  declare_parameter("pair_timeout", kDefaultParamPairTimeoutIndefinitely, pair_timeout_param_desc);
-
-  auto chk_conn_interval_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  chk_conn_interval_param_desc.name = "check_connection_interval";
-  chk_conn_interval_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  chk_conn_interval_param_desc.description =
-    "Sampling period, in seconds, to check if connection is alive. "
-    "The node will shutdown if connection is lost.";
-  declare_parameter(
-    "check_connection_interval", kDefaultParamCheckConnInterval, chk_conn_interval_param_desc);
-
-  auto publish_interval_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  publish_interval_param_desc.name = "publish_interval";
-  publish_interval_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_DOUBLE;
-  publish_interval_param_desc.description = "Sampling period, in seconds, to publish wiimote data.";
-  declare_parameter("publish_interval", kDefaultParamPublishInterval, publish_interval_param_desc);
-
-  auto req_motionplus_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  req_motionplus_param_desc.name = "require_motionplus";
-  req_motionplus_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
-  req_motionplus_param_desc.description =
-    "Set to true to ensure motionplus is connected on startup.";
-  declare_parameter(
-    "require_motionplus", kDefaultParamRequireMotionplus, req_motionplus_param_desc);
-
-  auto req_nunchuk_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  req_nunchuk_param_desc.name = "require_nunchuk";
-  req_nunchuk_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
-  req_nunchuk_param_desc.description = "Set to true to ensure nunchuk is connected on startup";
-  declare_parameter("require_nunchuk", kDefaultParamRequireNunchuk, req_nunchuk_param_desc);
-
-  auto req_classic_param_desc = rcl_interfaces::msg::ParameterDescriptor();
-  req_classic_param_desc.name = "require_classic";
-  req_classic_param_desc.type = rcl_interfaces::msg::ParameterType::PARAMETER_BOOL;
-  req_classic_param_desc.description = "Set to true to ensure classic is connected on startup.";
-  declare_parameter("require_classic", kDefaultParamRequireClassic, req_classic_param_desc);
-}
-
-using rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface;
-
-LifecycleNodeInterface::CallbackReturn WiimoteNode::on_configure(const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Configuring WiimoteNode.");
-
-  joy_pub_ = create_publisher<sensor_msgs::msg::Joy>(kDefaultJoyTopicNm, 1);
-  imu_data_pub_ = create_publisher<sensor_msgs::msg::Imu>(kDefaultImuDataTopicNm, 1);
-  wiimote_state_pub_ = create_publisher<wiimote_msgs::msg::State>(kDefaultWiimoteStateTopicNm, 1);
-  /**
-   * Optional Publications -- only advertise if the hardware is connected
-   * This is done in the main loop in the ::publish method
-   * wiimote_nunchuk_pub_ = create_publisher<sensor_msgs::msg::Joy>(kDefaultWiimoteNunchukTopicNm, 1);
-   * wiimote_classic_pub_ = create_publisher<sensor_msgs::msg::Joy>(kDefaultWiimoteClassicTopicNm, 1);
-   **/
-  imu_is_calibrated_pub_ = create_publisher<std_msgs::msg::Bool>(
-    kDefaultImuIsCalibTopicNm, rclcpp::QoS(1).transient_local());
-
-  joy_set_feedback_sub_ = create_subscription<sensor_msgs::msg::JoyFeedbackArray>(
-    kDefaultSetFeedbackTopicNm, 10,
-    std::bind(&WiimoteNode::joy_set_feedback_callback, this, std::placeholders::_1));
-
-  imu_calibrate_srv_ = create_service<std_srvs::srv::Empty>(
-    kDefaultImuCalibSrvNm, std::bind(
-      &WiimoteNode::service_imu_calibrate_callback, this,
-      std::placeholders::_1, std::placeholders::_2));
-
-  set_bluetooth_addr(get_parameter("bluetooth_addr").as_string().data());
-
-  wiimote_ = nullptr;
-
-  initialize_wiimote_state();
-
-  state_secs_ = 0;
-  state_nsecs_ = 0;
-
-  // Setup the Wii Error Handler
-  wiimote_c::cwiid_set_err(cwiid_error_callback);
-
-  report_mode_ = 0;
-
-  wiimote_calibrated_ = false;
-
-  reset_motion_plus_state();
-  reset_nunchuck_state();
-  reset_classic_state();
-  nunchuk_failed_calibration_ = false;
-
-  if (!pair_wiimote(0, get_parameter("pair_timeout").as_int())) {
-    RCLCPP_ERROR(logger_, "Configuration unsuccessful due to pairing failure. Try again.");
-    return LifecycleNodeInterface::CallbackReturn::FAILURE;
-  }
-
-  if (get_parameter("require_motionplus").as_bool() && !is_present_motionplus()) {
-    RCLCPP_ERROR(
-      logger_,
-      "Configuration requires motionplus but it was not detected. "
-      "Please make sure it is connected and try again.");
-    return CallbackReturn::FAILURE;
-  }
-
-  if (get_parameter("require_nunchuk").as_bool() && !is_present_nunchuk()) {
-    RCLCPP_ERROR(
-      logger_,
-      "Configuration requires nunchuk but it was not detected. "
-      "Please make sure it is connected and try again.");
-    return CallbackReturn::FAILURE;
-  }
-
-  if (get_parameter("require_classic").as_bool() && !is_present_classic()) {
-    RCLCPP_ERROR(
-      logger_,
-      "Configuration requires motionplus but it was not detected. "
-      "Please make sure it is connected and try again.");
-    return CallbackReturn::FAILURE;
-  }
-
-  if (get_parameter("require_motionplus").as_bool() && get_parameter("require_nunchuk").as_bool()) {
-    RCLCPP_ERROR(logger_, "Wiimote does not support connecting both motionplus and nunchuk.");
-  }
-
-  // TODO(knatsuki): Set SignalHandler?
-
-  return CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn WiimoteNode::on_activate(
-  const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Activating WiimoteNode.");
-  // Activate publishers
-  joy_pub_->on_activate();
-  imu_data_pub_->on_activate();
-  wiimote_state_pub_->on_activate();
-  if (wiimote_nunchuk_pub_) {
-    wiimote_nunchuk_pub_->on_activate();
-  }
-  if (wiimote_classic_pub_) {
-    wiimote_classic_pub_->on_activate();
-  }
-
-  check_connection_timer_ = create_wall_timer(
-    std::chrono::duration<double>(get_parameter("check_connection_interval").as_double()),
-    [this]() {this->check_connection();});
-  publish_timer_ = create_wall_timer(
-    std::chrono::duration<double>(get_parameter("publish_interval").as_double()),
-    [this]() {this->publish();});
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn
-WiimoteNode::on_deactivate(const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Deactivating WiimoteNode.");
-  // Delete timers
-  publish_timer_.reset();
-  check_connection_timer_.reset();
-  // Deactivate publishers
-  joy_pub_->on_deactivate();
-  imu_data_pub_->on_deactivate();
-  wiimote_state_pub_->on_deactivate();
-  if (wiimote_nunchuk_pub_) {
-    wiimote_nunchuk_pub_->on_deactivate();
-  }
-  if (wiimote_classic_pub_) {
-    wiimote_classic_pub_->on_deactivate();
-  }
-
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn WiimoteNode::on_cleanup(
-  const rclcpp_lifecycle::State &)
-{
-  RCLCPP_INFO(logger_, "Cleaning up WiimoteNode.");
-  // Reset ROS2 resources
-  publish_timer_.reset();
-  check_connection_timer_.reset();
-  joy_set_feedback_sub_.reset();
-  imu_calibrate_srv_.reset();
-  joy_pub_.reset();
-  imu_data_pub_.reset();
-  wiimote_state_pub_.reset();
-  if (wiimote_nunchuk_pub_) {
-    wiimote_nunchuk_pub_.reset();
-  }
-  if (wiimote_classic_pub_) {
-    wiimote_classic_pub_.reset();
-  }
-
-  if (unpair_wiimote()) {
-    RCLCPP_ERROR(logger_, "Error on wiimote disconnect");
-    return LifecycleNodeInterface::CallbackReturn::ERROR;
-  }
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn WiimoteNode::on_shutdown(
-  const rclcpp_lifecycle::State & previous_state)
-{
-  RCLCPP_INFO(
-    logger_, "Shutting down WiimoteNode. Previous State: %s, id: %d",
-    previous_state.label().c_str(), previous_state.id());
-
-  // Nothing to do if unconfigured
-  if (previous_state.id() == 1) {
-    return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-  }
-
-  // Reset ROS2 resources
-  publish_timer_.reset();
-  check_connection_timer_.reset();
-  joy_set_feedback_sub_.reset();
-  imu_calibrate_srv_.reset();
-  joy_pub_.reset();
-  imu_data_pub_.reset();
-  wiimote_state_pub_.reset();
-  if (wiimote_nunchuk_pub_) {
-    wiimote_nunchuk_pub_.reset();
-  }
-  if (wiimote_classic_pub_) {
-    wiimote_classic_pub_.reset();
-  }
-
-  if (unpair_wiimote()) {
-    RCLCPP_ERROR(logger_, "Error on wiimote disconnect");
-    return LifecycleNodeInterface::CallbackReturn::ERROR;
-  }
-  return LifecycleNodeInterface::CallbackReturn::SUCCESS;
-}
-
-rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn WiimoteNode::on_error(
-  const rclcpp_lifecycle::State & previous_state)
-{
-  RCLCPP_INFO(
-    logger_, "Error handling WiimoteNode. Previous State: %s, id: %d",
-    previous_state.label().c_str(), previous_state.id());
-  return LifecycleNodeInterface::CallbackReturn::FAILURE;
-}
-
-char * WiimoteNode::get_bluetooth_addr() {return batostr(&bt_device_addr_);}
-
-void WiimoteNode::set_bluetooth_addr(const char * bt_str) {str2ba(bt_str, &bt_device_addr_);}
-
-bool WiimoteNode::pair_wiimote(int flags = 0, int timeout = 5)
-{
-  RCLCPP_INFO(logger_, "Pairing Wiimote.");
-
-  auto bt_addr = get_bluetooth_addr();
-  if (strcmp(bt_addr, kDefaultParamBluetoothAddrAny) == 0) {
-    RCLCPP_INFO(logger_, "Bluetooth address not specified. Will connect to any device found.");
-  } else {
-    RCLCPP_INFO(logger_, "* * * Pairing with %s", bt_addr);
-  }
-
-  bool status = true;
-
-  RCLCPP_INFO(logger_, "Put Wiimote in discoverable mode now (press 1+2)...");
-  if (timeout == -1) {
-    RCLCPP_INFO(logger_, "Searching indefinitely...");
-  } else {
-    RCLCPP_INFO(logger_, "Timeout in about %d seconds if not paired.", timeout);
-  }
-
-  if (!(wiimote_ = wiimote_c::cwiid_open_timeout(&bt_device_addr_, flags, timeout))) {
-    RCLCPP_ERROR(logger_, "Unable to connect to wiimote");
-    status = false;
-  } else {
-    RCLCPP_INFO(logger_, "Paired to %s.", get_bluetooth_addr());
-    RCLCPP_INFO(logger_, "Calibrating device...");
-    RCLCPP_INFO(logger_, "Allow all joy sticks to remain at center position until calibrated.");
-    // Give the hardware time to zero the accelerometer and gyro after pairing
-    // Ensure we are getting valid data before using
-    std::this_thread::sleep_for(std::chrono::seconds(1));
-
-    check_factory_calibration_data();
-
-    if (!wiimote_calibrated_) {
-      RCLCPP_ERROR(logger_, "Wiimote not usable due to calibration failure.");
-      unpair_wiimote();
-      status = false;
-    }
-  }
-
-  return status;
-}
-
-int WiimoteNode::unpair_wiimote()
-{
-  RCLCPP_INFO(logger_, "Unpairing wiimote.");
-  return wiimote_c::cwiid_close(wiimote_);
-}
-
-void WiimoteNode::check_connection()
-{
-  if (wiimote_c::cwiid_set_led(wiimote_, led_state_)) {
-    RCLCPP_ERROR(logger_, "device connection lost. Shutting down node.");
-    shutdown();
-  }
-}
-
-void WiimoteNode::cwiid_error_callback(
-  wiimote_c::cwiid_wiimote_t * wiimote, const char * fmt, va_list ap)
-{
-  const int MAX_BUF = 500;
-  char msgs_buf[MAX_BUF];
-
-  vsnprintf(msgs_buf, MAX_BUF, fmt, ap);
-
-  auto logger = rclcpp::get_logger("cwiid_error_callback");
-  if (wiimote) {
-    RCLCPP_ERROR(logger, "Wii Error: ID: %d: %s", wiimote_c::cwiid_get_id(wiimote), msgs_buf);
-  } else {
-    RCLCPP_ERROR(logger, "Wii Error: ID: ?: %s", msgs_buf);
-  }
-}
-
-void WiimoteNode::reset_motion_plus_state()
-{
-  // If no gyro is attached to the Wiimote then we signal
-  // the invalidity of angular rate with a covariance matrix
-  // whose first element is -1:
-  angular_velocity_covariance_[0] = -1.0;
-  angular_velocity_covariance_[1] = 0.0;
-  angular_velocity_covariance_[2] = 0.0;
-
-  angular_velocity_covariance_[3] = 0.0;
-  angular_velocity_covariance_[4] = 0.0;
-  angular_velocity_covariance_[5] = 0.0;
-
-  angular_velocity_covariance_[6] = 0.0;
-  angular_velocity_covariance_[7] = 0.0;
-  angular_velocity_covariance_[8] = 0.0;
-}
-
-void WiimoteNode::reset_nunchuck_state()
-{
-  nunchuk_calibrated_ = false;
-
-  nunchuk_stick_calibrated_ = false;
-  nunchuk_stick_center_[CWIID_X] = JOYSTICK_NUNCHUK_DEFAULT_CENTER_;
-  nunchuk_stick_center_[CWIID_Y] = JOYSTICK_NUNCHUK_DEFAULT_CENTER_;
-  nunchuk_stick_max_[CWIID_X] = JOYSTICK_NUNCHUK_20PERCENT_MAX_;
-  nunchuk_stick_max_[CWIID_Y] = JOYSTICK_NUNCHUK_20PERCENT_MAX_;
-  nunchuk_stick_min_[CWIID_X] = JOYSTICK_NUNCHUK_20PERCENT_MIN_;
-  nunchuk_stick_min_[CWIID_Y] = JOYSTICK_NUNCHUK_20PERCENT_MIN_;
-}
-
-void WiimoteNode::reset_classic_state()
-{
-  classic_stick_left_calibrated_ = false;
-  classic_stick_right_calibrated_ = false;
-  classic_stick_left_center_[CWIID_X] = JOYSTICK_CLASSIC_LEFT_DEFAULT_CENTER_;
-  classic_stick_left_center_[CWIID_Y] = JOYSTICK_CLASSIC_LEFT_DEFAULT_CENTER_;
-  classic_stick_right_center_[CWIID_X] = JOYSTICK_CLASSIC_RIGHT_DEFAULT_CENTER_;
-  classic_stick_right_center_[CWIID_Y] = JOYSTICK_CLASSIC_RIGHT_DEFAULT_CENTER_;
-  classic_stick_left_max_[CWIID_X] = JOYSTICK_CLASSIC_LEFT_20PERCENT_MAX_;
-  classic_stick_left_max_[CWIID_Y] = JOYSTICK_CLASSIC_LEFT_20PERCENT_MAX_;
-  classic_stick_left_min_[CWIID_X] = JOYSTICK_CLASSIC_LEFT_20PERCENT_MIN_;
-  classic_stick_left_min_[CWIID_Y] = JOYSTICK_CLASSIC_LEFT_20PERCENT_MIN_;
-  classic_stick_right_max_[CWIID_X] = JOYSTICK_CLASSIC_RIGHT_20PERCENT_MAX_;
-  classic_stick_right_max_[CWIID_Y] = JOYSTICK_CLASSIC_RIGHT_20PERCENT_MAX_;
-  classic_stick_right_min_[CWIID_X] = JOYSTICK_CLASSIC_RIGHT_20PERCENT_MIN_;
-  classic_stick_right_min_[CWIID_Y] = JOYSTICK_CLASSIC_RIGHT_20PERCENT_MIN_;
-}
-
-void WiimoteNode::joy_set_feedback_callback(
-  sensor_msgs::msg::JoyFeedbackArray::ConstSharedPtr feedback)
-{
-  bool led_found = false;
-  bool rumble_found = false;
-
-  for (std::vector<sensor_msgs::msg::JoyFeedback>::const_iterator it = feedback->array.begin();
-    it != feedback->array.end(); ++it)
-  {
-    if ((*it).type == sensor_msgs::msg::JoyFeedback::TYPE_LED) {
-      led_found = true;
-
-      if ((*it).intensity >= 0.5) {
-        set_led_bit((*it).id, true);
-      } else {
-        set_led_bit((*it).id, false);
-      }
-    } else if ((*it).type == sensor_msgs::msg::JoyFeedback::TYPE_RUMBLE) {
-      if ((*it).id > 0) {
-        RCLCPP_WARN(logger_, "RUMBLE ID %d out of bounds; ignoring!", (*it).id);
-      } else {
-        rumble_found = true;
-
-        if ((*it).intensity >= 0.5) {
-          set_rumble_bit(true);
-        } else {
-          set_rumble_bit(false);
-        }
-      }
-    } else {
-      RCLCPP_WARN(logger_, "Unknown JoyFeedback command; ignored");
-    }
-  }
-
-  if (led_found) {
-    set_led_state(led_state_);
-  }
-
-  if (rumble_found) {
-    set_rumble_state(rumble_);
-  }
-}
-
-void WiimoteNode::set_led_bit(uint8_t led, bool on)
-{
-  uint8_t bit;
-
-  if (led > 3) {
-    RCLCPP_WARN(logger_, "LED ID %d out of bounds; ignoring!", led);
-  }
-
-  bit = 1 << led;
-
-  if (on) {  // Set bit
-    led_state_ |= bit;
-  } else {  // Clear bit
-    led_state_ &= ~(bit);
-  }
-}
-void WiimoteNode::set_rumble_bit(bool on)
-{
-  if (on) {  // Set bit
-    rumble_ |= 0x1;
-  } else {  // Clear bit
-    rumble_ &= ~(0x1);
-  }
-}
-
-void WiimoteNode::set_led_state(uint8_t led_state)
-{
-  if (wiimote_c::cwiid_set_led(wiimote_, led_state)) {
-    RCLCPP_ERROR(logger_, "Error setting LEDs");
-  }
-}
-
-void WiimoteNode::set_rumble_state(uint8_t rumble)
-{
-  if (wiimote_c::cwiid_set_rumble(wiimote_, rumble)) {
-    RCLCPP_ERROR(logger_, "Error setting rumble");
-  }
-}
-
-bool WiimoteNode::service_imu_calibrate_callback(
-  std_srvs::srv::Empty::Request::SharedPtr, std_srvs::srv::Empty::Response::SharedPtr)
-{
-  // Publish the new calibration state
-  check_factory_calibration_data();
-
-  return true;
-}
-
-void WiimoteNode::check_factory_calibration_data()
-{
-  bool result = true;
-
-  if (wiimote_c::cwiid_get_acc_cal(wiimote_, wiimote_c::CWIID_EXT_NONE, &wiimote_cal_) != 0) {
-    if (wiimote_calibrated_) {
-      RCLCPP_WARN(
-        logger_, "Failed to read current Wiimote calibration data; proceeding with previous data");
-    } else {
-      RCLCPP_ERROR(logger_, "Failed to read Wiimote factory calibration data");
-      result = false;
-    }
-  } else {
-    // If any calibration point is zero; we fail
-    if (!(wiimote_cal_.zero[CWIID_X] && wiimote_cal_.zero[CWIID_Y] && wiimote_cal_.zero[CWIID_Z] &&
-      wiimote_cal_.one[CWIID_X] && wiimote_cal_.one[CWIID_Y] && wiimote_cal_.one[CWIID_Z]))
-    {
-      RCLCPP_ERROR(logger_, "Some Wiimote factory calibration data is missing; calibration failed");
-      RCLCPP_ERROR(
-        logger_,
-        "Wiimote Cal:: zero[x]:%d, zero[y]:%d, zero[z]:%d,\n\tone[x]:%d, one[y]:%d, one[z]:%d",
-        wiimote_cal_.zero[CWIID_X], wiimote_cal_.zero[CWIID_Y], wiimote_cal_.zero[CWIID_Z],
-        wiimote_cal_.one[CWIID_X], wiimote_cal_.one[CWIID_Y], wiimote_cal_.one[CWIID_Z]);
-
-      result = false;
-    } else {
-      wiimote_calibrated_ = true;
-      RCLCPP_DEBUG(
-        logger_,
-        "Wiimote Cal:: zero[x]:%d, zero[y]:%d, zero[z]:%d,\n\tone[x]:%d, one[y]:%d, one[z]:%d",
-        wiimote_cal_.zero[CWIID_X], wiimote_cal_.zero[CWIID_Y], wiimote_cal_.zero[CWIID_Z],
-        wiimote_cal_.one[CWIID_X], wiimote_cal_.one[CWIID_Y], wiimote_cal_.one[CWIID_Z]);
-    }
-  }
-
-  if (!get_state_sample()) {
-    RCLCPP_WARN(logger_, "Could not read Wiimote state; nunchuk may not be calibrated if present.");
-  } else {
-    if (is_present_nunchuk()) {
-      if (
-        wiimote_c::cwiid_get_acc_cal(wiimote_, wiimote_c::CWIID_EXT_NUNCHUK, &nunchuk_cal_) != 0)
-      {
-        if (nunchuk_calibrated_) {
-          RCLCPP_WARN(
-            logger_,
-            "Failed to read current Nunchuk calibration data; proceeding with previous data");
-        } else {
-          RCLCPP_ERROR(logger_, "Failed to read Nunchuk factory calibration data");
-          result = false;
-          nunchuk_failed_calibration_ = true;
-        }
-      } else {
-        // If any calibration point is zero; we fail
-        if (!(nunchuk_cal_.zero[CWIID_X] && nunchuk_cal_.zero[CWIID_Y] &&
-          nunchuk_cal_.zero[CWIID_Z] && nunchuk_cal_.one[CWIID_X] &&
-          nunchuk_cal_.one[CWIID_Y] && nunchuk_cal_.one[CWIID_Z]))
-        {
-          RCLCPP_ERROR(
-            logger_, "Some Nunchuk factory calibration data is missing; calibration failed");
-          RCLCPP_ERROR(
-            logger_,
-            "Nunchuk Cal:: zero[x]:%d, zero[y]:%d, zero[z]:%d,\n\tone[x]:%d, one[y]:%d, one[z]:%d",
-            nunchuk_cal_.zero[CWIID_X], nunchuk_cal_.zero[CWIID_Y], nunchuk_cal_.zero[CWIID_Z],
-            nunchuk_cal_.one[CWIID_X], nunchuk_cal_.one[CWIID_Y], nunchuk_cal_.one[CWIID_Z]);
-          result = false;
-          nunchuk_failed_calibration_ = true;
-        } else {
-          nunchuk_calibrated_ = true;
-          RCLCPP_DEBUG(
-            logger_,
-            "Nunchuk Cal:: zero[x]:%d, zero[y]:%d, zero[z]:%d,\n\tone[x]:%d, one[y]:%d, one[z]:%d",
-            nunchuk_cal_.zero[CWIID_X], nunchuk_cal_.zero[CWIID_Y], nunchuk_cal_.zero[CWIID_Z],
-            nunchuk_cal_.one[CWIID_X], nunchuk_cal_.one[CWIID_Y], nunchuk_cal_.one[CWIID_Z]);
-        }
-      }
-    }
-  }
-
-  if (wiimote_calibrated_) {
-    // Save the current reporting mode
-    uint8_t save_report_mode = wiimote_state_.rpt_mode;
-
-    // Need to ensure we are collecting accelerometer
-    uint8_t new_report_mode = save_report_mode | (CWIID_RPT_ACC | CWIID_RPT_EXT);
-
-    if (new_report_mode != save_report_mode) {
-      set_report_mode(new_report_mode);
-    }
-
-    RCLCPP_INFO(logger_, "Collecting additional calibration data; keep wiimote stationary...");
-
-    StatVector3d linear_acceleration_stat_old = linear_acceleration_stat_;
-    linear_acceleration_stat_.clear();
-    StatVector3d angular_velocity_stat_old = angular_velocity_stat_;
-    angular_velocity_stat_.clear();
-
-    bool failed = false;
-    bool data_complete = false;
-    int wiimote_data_points = 0;
-    int motionplus_data_points = 0;
-
-    while (!failed && !data_complete) {
-      if (get_state_sample()) {
-        if (wiimote_data_points < COVARIANCE_DATA_POINTS_) {
-          linear_acceleration_stat_.addData(
-            wiimote_state_.acc[CWIID_X], wiimote_state_.acc[CWIID_Y], wiimote_state_.acc[CWIID_Z]);
-
-          ++wiimote_data_points;
-        }
-
-        if (is_present_motionplus()) {
-          if (motionplus_data_points < COVARIANCE_DATA_POINTS_) {
-            // RCLCPP_DEBUG(
-            //   logger_, "New MotionPlus data :%03d: PHI: %04d, THETA: %04d, PSI: %04d",
-            //   motionplus_data_points, wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI],
-            //   wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA],
-            //   wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI]);
-            // angular_velocity_stat_.addData(
-            //   wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI],
-            //   wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA],
-            //   wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI]);
-
-            ++motionplus_data_points;
-          }
-        }
-      } else {
-        failed = true;
-      }
-
-      if (wiimote_data_points >= COVARIANCE_DATA_POINTS_) {
-        if (!is_present_motionplus()) {
-          data_complete = true;
-        } else {
-          if (motionplus_data_points >= COVARIANCE_DATA_POINTS_) {
-            data_complete = true;
-          }
-        }
-      }
-    }
-
-    if (!failed) {
-      RCLCPP_DEBUG(logger_, "Calculating calibration data...");
-
-      // Check the standard deviations > 1.0
-      TVectorDouble stddev = linear_acceleration_stat_.getStandardDeviationRaw();
-      bool is_bad_cal = false;
-      std::for_each(
-        std::begin(stddev), std::end(stddev),
-        [&](const double d)  // NOLINT(build/c++11)
-        {
-          if (d > 1.0) {
-            is_bad_cal = true;
-            RCLCPP_DEBUG(logger_, "Wiimote standard deviation > 1.0");
-          }
-        });  // NOLINT(whitespace/braces)
-
-      if (!is_bad_cal) {
-        TVectorDouble variance = linear_acceleration_stat_.getVarianceScaled(EARTH_GRAVITY_);
-
-        RCLCPP_DEBUG(
-          logger_, "Variance Scaled x: %lf, y: %lf, z: %lf", variance.at(CWIID_X),
-          variance.at(CWIID_Y), variance.at(CWIID_Z));
-
-        linear_acceleration_covariance_[0] = variance.at(CWIID_X);
-        linear_acceleration_covariance_[1] = 0.0;
-        linear_acceleration_covariance_[2] = 0.0;
-
-        linear_acceleration_covariance_[3] = 0.0;
-        linear_acceleration_covariance_[4] = variance.at(CWIID_Y);
-        linear_acceleration_covariance_[5] = 0.0;
-
-        linear_acceleration_covariance_[6] = 0.0;
-        linear_acceleration_covariance_[7] = 0.0;
-        linear_acceleration_covariance_[8] = variance.at(CWIID_Z);
-      } else {
-        RCLCPP_ERROR(
-          logger_, "Failed calibration; using questionable data for linear acceleration");
-
-        linear_acceleration_stat_ = linear_acceleration_stat_old;
-        angular_velocity_stat_ = angular_velocity_stat_old;
-
-        result = false;
-      }
-
-      if (angular_velocity_stat_.size() == COVARIANCE_DATA_POINTS_) {
-        // Check the standard deviations > 50.0
-        TVectorDouble gyro_stddev = angular_velocity_stat_.getStandardDeviationRaw();
-        std::for_each(
-          std::begin(gyro_stddev), std::end(gyro_stddev),
-          [&](const double d)  // NOLINT(build/c++11)
-          {
-            if (d > 50.0) {
-              is_bad_cal = true;
-              RCLCPP_DEBUG(logger_, "MotionPlus standard deviation > 50");
-            }
-          });  // NOLINT(whitespace/braces)
-
-        if (!is_bad_cal) {
-          TVectorDouble gyro_variance =
-            angular_velocity_stat_.getVarianceScaled(GYRO_SCALE_FACTOR_);
-
-          RCLCPP_DEBUG(
-            logger_, "Gyro Variance Scaled x: %lf, y: %lf, z: %lf", gyro_variance.at(CWIID_PHI),
-            gyro_variance.at(CWIID_THETA), gyro_variance.at(CWIID_PSI));
-
-          angular_velocity_covariance_[0] = gyro_variance.at(CWIID_PHI);
-          angular_velocity_covariance_[1] = 0.0;
-          angular_velocity_covariance_[2] = 0.0;
-
-          angular_velocity_covariance_[3] = 0.0;
-          angular_velocity_covariance_[4] = gyro_variance.at(CWIID_THETA);
-          angular_velocity_covariance_[5] = 0.0;
-
-          angular_velocity_covariance_[6] = 0.0;
-          angular_velocity_covariance_[7] = 0.0;
-          angular_velocity_covariance_[8] = gyro_variance.at(CWIID_PSI);
-        } else {
-          RCLCPP_ERROR(logger_, "Failed calibration; using questionable data for angular velocity");
-
-          angular_velocity_stat_ = angular_velocity_stat_old;
-
-          result = false;
-        }
-      } else {
-        reset_motion_plus_state();
-      }
-    }
-
-    if (failed) {
-      RCLCPP_ERROR(logger_, "Failed calibration; using questionable data");
-      result = false;
-    } else {
-      struct timespec state_tv;
-
-      if (clock_gettime(CLOCK_REALTIME, &state_tv) == 0) {
-        calibration_time_ = now();
-      } else {
-        RCLCPP_WARN(logger_, "Could not update calibration time.");
-      }
-    }
-
-    // Restore the pre-existing reporting mode
-    if (new_report_mode != save_report_mode) {
-      set_report_mode(save_report_mode);
-    }
-  }
-
-  // Publish the initial calibration state
-  std_msgs::msg::Bool imu_is_calibrated_data;
-  imu_is_calibrated_data.data = result;
-  imu_is_calibrated_pub_->publish(imu_is_calibrated_data);
-}
-
-void WiimoteNode::set_report_mode(uint8_t rpt_mode)
-{
-  RCLCPP_DEBUG(logger_, "Change report mode from %d to %d", wiimote_state_.rpt_mode, rpt_mode);
-
-  if (wiimote_c::cwiid_set_rpt_mode(wiimote_, rpt_mode)) {
-    RCLCPP_ERROR(logger_, "Error setting report mode: Bit(s):%d", rpt_mode);
-    // TODO(knatsuki): Do more than log error?
-  } else {
-    wiimote_state_.rpt_mode = rpt_mode;
-
-    // Enable the MotionPlus
-    if (rpt_mode & CWIID_RPT_MOTIONPLUS) {
-      wiimote_c::cwiid_enable(wiimote_, CWIID_FLAG_MOTIONPLUS);
-      RCLCPP_DEBUG(logger_, "Enabled MotionPlus");
-    }
-  }
-}
-
-bool WiimoteNode::is_collecting_wiimote()
-{
-  return wiimote_state_.rpt_mode & (CWIID_RPT_BTN | CWIID_RPT_ACC | CWIID_RPT_IR);
-}
-
-bool WiimoteNode::is_collecting_nunchuk() {return wiimote_state_.rpt_mode & CWIID_RPT_NUNCHUK;}
-
-bool WiimoteNode::is_collecting_classic() {return wiimote_state_.rpt_mode & CWIID_RPT_CLASSIC;}
-
-bool WiimoteNode::is_collecting_motionplus()
-{
-  return wiimote_state_.rpt_mode & CWIID_RPT_MOTIONPLUS;
-}
-
-bool WiimoteNode::is_present_nunchuk()
-{
-  return wiimote_state_.ext_type == wiimote_c::CWIID_EXT_NUNCHUK;
-}
-
-bool WiimoteNode::is_present_classic()
-{
-  return wiimote_state_.ext_type == wiimote_c::CWIID_EXT_CLASSIC;
-}
-
-bool WiimoteNode::is_present_motionplus()
-{
-  return wiimote_state_.ext_type == wiimote_c::CWIID_EXT_MOTIONPLUS;
-}
-
-void WiimoteNode::initialize_wiimote_state()
-{
-  wiimote_state_.rpt_mode = 0;
-  wiimote_state_.led = 0;
-  wiimote_state_.rumble = 0;
-  wiimote_state_.battery = 0;
-  wiimote_state_.buttons = 0;
-  wiimote_state_.acc[0] = 0;
-  wiimote_state_.acc[1] = 0;
-  wiimote_state_.acc[2] = 0;
-
-  wiimote_state_.ext_type = wiimote_c::CWIID_EXT_NONE;
-  wiimote_state_.error = wiimote_c::CWIID_ERROR_NONE;
-
-  wiimote_state_.ir_src[0].valid = 0;
-  wiimote_state_.ir_src[1].valid = 0;
-  wiimote_state_.ir_src[2].valid = 0;
-  wiimote_state_.ir_src[3].valid = 0;
-  wiimote_state_.ir_src[0].pos[0] = 0;
-  wiimote_state_.ir_src[0].pos[1] = 0;
-  wiimote_state_.ir_src[1].pos[0] = 0;
-  wiimote_state_.ir_src[1].pos[1] = 0;
-  wiimote_state_.ir_src[2].pos[0] = 0;
-  wiimote_state_.ir_src[2].pos[1] = 0;
-  wiimote_state_.ir_src[3].pos[0] = 0;
-  wiimote_state_.ir_src[3].pos[1] = 0;
-  wiimote_state_.ir_src[0].size = 0;
-  wiimote_state_.ir_src[1].size = 0;
-  wiimote_state_.ir_src[2].size = 0;
-  wiimote_state_.ir_src[3].size = 0;
-}
-
-bool WiimoteNode::get_state_sample()
-{
-  bool result = true;
-  bool get_state_result = true;
-  bool data_valid = false;
-
-  int count = 0;
-  int big_count = 0;
-  static int wiimote_count = 0;
-  static int motionplus_count = 0;
-
-  do {
-    get_state_result = (wiimote_c::cwiid_get_state(wiimote_, &wiimote_state_) == 0);
-
-    if (
-      is_collecting_wiimote() &&
-      (wiimote_state_.acc[CWIID_X] == 0 && wiimote_state_.acc[CWIID_Y] == 0 &&
-      wiimote_state_.acc[CWIID_Z] == 0))
-    {
-      if (count > 1 && !(count % 100)) {
-        // If we can not get valid data from the Wiimote, wait and try again
-        RCLCPP_INFO(logger_, "Waiting for valid wiimote data...");
-        count = 0;
-        ++big_count;
-      }
-
-      std::this_thread::sleep_for(std::chrono::milliseconds(10));  // wait 10ms
-      ++count;
-      if (big_count > 10) {
-        get_state_result = false;
-      }
-    } else {
-      if (wiimote_count < IGNORE_DATA_POINTS_) {
-        // RCLCPP_DEBUG(debugger_, "Ignoring Wiimote data point %d", wiimote_count);
-        wiimote_count++;
-      } else {
-        data_valid = true;
-      }
-    }
-
-    std::this_thread::sleep_for(std::chrono::milliseconds(10));  // wait 10ms
-  } while (get_state_result && !data_valid);
-
-  if (is_present_motionplus()) {
-    data_valid = false;
-
-    count = 0;
-    big_count = 0;
-
-    do {
-      if (
-        wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI] == 0 &&
-        wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA] == 0 &&
-        wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI] == 0)
-      {
-        if (count > 1 && !(count % 100)) {
-          // If we can not get valid data from the Wiimote, wait and try again
-          RCLCPP_INFO(logger_, "Waiting for valid MotionPlus data...");
-          count = 0;
-          ++big_count;
-        }
-
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));  // wait 10 ms
-        ++count;
-        if (big_count > 10) {
-          get_state_result = false;
-        } else {
-          std::this_thread::sleep_for(std::chrono::milliseconds(10));  // wait 10 ms
-          get_state_result = (wiimote_c::cwiid_get_state(wiimote_, &wiimote_state_) == 0);
-        }
-      } else {
-        if (motionplus_count < IGNORE_DATA_POINTS_) {
-          RCLCPP_DEBUG(logger_, "Ignoring MotionPlus data point %d", motionplus_count);
-          motionplus_count++;
-          std::this_thread::sleep_for(std::chrono::milliseconds(1));  // wait 1ms
-        } else {
-          data_valid = true;
-          // Get a new data point with valid data
-          get_state_result = (wiimote_c::cwiid_get_state(wiimote_, &wiimote_state_) == 0);
-        }
-      }
-    } while (get_state_result && !data_valid);
-  } else {
-    // MotionPlus was removed, so reset the master count
-    motionplus_count = 0;
-    reset_motion_plus_state();
-  }
-
-  if (get_state_result) {
-    struct timespec state_tv;
-
-    if (clock_gettime(CLOCK_REALTIME, &state_tv) == 0) {
-      state_secs_ = state_tv.tv_sec;
-      state_nsecs_ = state_tv.tv_nsec;
-    } else {
-      RCLCPP_ERROR(logger_, "Error sampling real-time clock");
-      result = false;
-    }
-  } else {
-    result = false;
-  }
-
-  return result;
-}
-
-void WiimoteNode::publish()
-{
-  auto joy_subscribers = joy_pub_->get_subscription_count();
-  auto wii_state_subscribers = wiimote_state_pub_->get_subscription_count();
-  auto imu_subscribers = imu_data_pub_->get_subscription_count();
-  size_t wii_nunchuk_subscribers = 0;
-  size_t wii_classic_subscribers = 0;
-
-  auto current_report_mode = wiimote_state_.rpt_mode;
-  auto new_report_mode = current_report_mode;
-
-  /*              CWIID_RPT_xxx
-
-                  | | | |M| | |
-                  | | | |O| | |
-                  | | | |T| | |
-                  | | | |I|N|C|
-                  | | | |O|U|L|
-                  | | | |N|N|A|
-                  | | | |P|C|S|
-                  | |B|A|L|H|S|
-                  |I|T|C|U|U|I|
-  ROS_Topic       |R|N|C|S|K|C|
-                  |_|_|_|_|_|_|
-  joy             | |x|x|x| | |
-  imu_data        | | |x|x| | |
-  wiimote_state   |x|x|x|x|x| |
-  wiimote_nunchuk | | | | |x| |
-  wiimote_classic | | | | | |x|
-  */
-
-  if (joy_subscribers || wii_state_subscribers || imu_subscribers) {
-    // Need to collect data on accelerometer and motionplus
-    new_report_mode |= (CWIID_RPT_ACC | CWIID_RPT_MOTIONPLUS);
-
-    if (joy_subscribers || wii_state_subscribers) {
-      // Need to also collect data on buttons
-      new_report_mode |= (CWIID_RPT_BTN);
-    }
-
-    if (wii_state_subscribers) {
-      // Need to also collect data on IR and Nunchuk
-      new_report_mode |= (CWIID_RPT_IR | CWIID_RPT_NUNCHUK);
-    }
-  } else {
-    if (!joy_subscribers && !wii_state_subscribers && !imu_subscribers) {
-      // Can stop collecting data on accelerometer and motionplus
-      new_report_mode &= ~(CWIID_RPT_ACC | CWIID_RPT_MOTIONPLUS);
-    }
-
-    if (!joy_subscribers && !wii_state_subscribers) {
-      // Can also stop collecting data on buttons
-      new_report_mode &= ~(CWIID_RPT_BTN);
-    }
-
-    if (!wii_state_subscribers) {
-      // Can also stop collecting data on IR
-      new_report_mode &= ~(CWIID_RPT_IR);
-    }
-  }
-
-  // Is the Nunchuk connected?
-  if (is_present_nunchuk()) {
-    // Is the Nunchuk publisher not advertised?
-    if (nullptr == wiimote_nunchuk_pub_) {
-      if (!nunchuk_failed_calibration_) {
-        // The nunchuk was just connected, so read the calibration data
-        if (!nunchuk_calibrated_) {
-          check_factory_calibration_data();
-        }
-
-        if (nunchuk_calibrated_) {
-          wiimote_nunchuk_pub_ =
-            create_publisher<sensor_msgs::msg::Joy>(kDefaultWiimoteNunchukTopicNm, 1);
-          wiimote_nunchuk_pub_->on_activate();
-        } else {
-          RCLCPP_ERROR(logger_, "Topic /wiimote/nunchuk not advertised due to calibration failure");
-        }
-      }
-    }
-
-    wii_nunchuk_subscribers = wiimote_nunchuk_pub_->get_subscription_count();
-
-    if (wii_nunchuk_subscribers) {
-      // Need to collect data on nunchuk
-      new_report_mode |= (CWIID_RPT_NUNCHUK);
-    } else {
-      if (!wii_state_subscribers) {
-        // Can stop collecting data on nunchuk
-        new_report_mode &= ~(CWIID_RPT_NUNCHUK);
-      }
-    }
-  } else {  // Stop publishing the topic
-    // Is the Nunchuk publisher advertised?
-    if (nullptr != wiimote_nunchuk_pub_) {
-      wiimote_nunchuk_pub_.reset();
-
-      reset_nunchuck_state();
-
-      if (!wii_state_subscribers) {
-        // Can stop collecting data on nunchuk
-        new_report_mode &= ~(CWIID_RPT_NUNCHUK);
-      }
-    }
-
-    // If the nunchuk was connect, but failed calibration
-    // then attempt to check factory calibration for the wiimote
-    if (nunchuk_failed_calibration_) {
-      check_factory_calibration_data();
-      nunchuk_failed_calibration_ = false;
-    }
-  }
-
-  // Is the Classic Pad connected?
-  if (is_present_classic()) {
-    // Is the Classic Pad publisher not advertised?
-    if (nullptr == wiimote_classic_pub_) {
-      wiimote_classic_pub_ =
-        create_publisher<sensor_msgs::msg::Joy>(kDefaultWiimoteClassicTopicNm, 1);
-      wiimote_classic_pub_->on_activate();
-    }
-
-    wii_classic_subscribers = wiimote_classic_pub_->get_subscription_count();
-
-    if (wii_classic_subscribers) {
-      // Need to collect data on classic
-      new_report_mode |= (CWIID_RPT_CLASSIC);
-    } else {
-      // Can stop collecting data on classic
-      new_report_mode &= ~(CWIID_RPT_CLASSIC);
-    }
-  } else {  // Stop publishing the topic
-    // Is the Classic Pad publisher advertised?
-    if (nullptr != wiimote_classic_pub_) {
-      wiimote_classic_pub_.reset();
-
-      reset_classic_state();
-
-      // Can stop collecting data on classic
-      new_report_mode &= ~(CWIID_RPT_CLASSIC);
-    }
-  }
-
-  // Update the reporting mode and returning
-  if (current_report_mode != new_report_mode) {
-    set_report_mode(new_report_mode);
-  }
-
-  if (
-    !joy_subscribers && !wii_state_subscribers && !imu_subscribers &&
-    !wii_nunchuk_subscribers & !wii_classic_subscribers)
-  {
-    return;
-  }  // If there are no subscribers, there isn't anything to publish
-
-  if (!get_state_sample()) {
-    // If we can not get State from the Wiimote, there isn't anything to publish
-    return;
-  }
-
-  if (joy_subscribers) {
-    publish_joy();
-  }
-
-  if (imu_subscribers) {
-    publish_imu_data();
-  }
-
-  if (wii_state_subscribers) {
-    publish_wiimote_state();
-  }
-
-  if (wii_nunchuk_subscribers) {
-    publish_wiimote_nunchuk();
-  }
-
-  // Is the Classic Pad connected?
-  if (wii_classic_subscribers) {
-    publish_wiimote_classic();
-  }
-}
-void WiimoteNode::publish_joy()
-{
-  sensor_msgs::msg::Joy joy_data;
-
-  joy_data.header.stamp.sec = state_secs_;
-  joy_data.header.stamp.nanosec = state_nsecs_;
-
-  joy_data.axes.push_back(
-    zeroedByCal(
-      wiimote_state_.acc[CWIID_X], wiimote_cal_.zero[CWIID_X], wiimote_cal_.one[CWIID_X]) *
-    EARTH_GRAVITY_);
-  joy_data.axes.push_back(
-    zeroedByCal(
-      wiimote_state_.acc[CWIID_Y], wiimote_cal_.zero[CWIID_Y], wiimote_cal_.one[CWIID_Y]) *
-    EARTH_GRAVITY_);
-  joy_data.axes.push_back(
-    zeroedByCal(
-      wiimote_state_.acc[CWIID_Z], wiimote_cal_.zero[CWIID_Z], wiimote_cal_.one[CWIID_Z]) *
-    EARTH_GRAVITY_);
-
-  // NOTE: Order is different for /wiimote/state
-  // Keep consistency with existing Python Node
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_1) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_2) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_A) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_B) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_PLUS) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_MINUS) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_LEFT) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_RIGHT) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_UP) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_DOWN) > 0);
-  joy_data.buttons.push_back((wiimote_state_.buttons & CWIID_BTN_HOME) > 0);
-
-  joy_pub_->publish(joy_data);
-}
-
-void WiimoteNode::publish_imu_data()
-{
-  // The Wiimote provides the Acceleration and optionally Gyro
-  // if MotionPlus is available, but not orientation information.
-
-  sensor_msgs::msg::Imu imu_data_data;
-
-  imu_data_data.header.stamp.sec = state_secs_;
-  imu_data_data.header.stamp.nanosec = state_nsecs_;
-
-  // Publish that Orientation data is invalid
-  // [ -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ]
-  imu_data_data.orientation_covariance[0] = -1.0;
-
-  // Acceleration
-  imu_data_data.linear_acceleration.x =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_X], wiimote_cal_.zero[CWIID_X], wiimote_cal_.one[CWIID_X]) *
-    EARTH_GRAVITY_;
-  imu_data_data.linear_acceleration.y =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_Y], wiimote_cal_.zero[CWIID_Y], wiimote_cal_.one[CWIID_Y]) *
-    EARTH_GRAVITY_;
-  imu_data_data.linear_acceleration.z =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_Z], wiimote_cal_.zero[CWIID_Z], wiimote_cal_.one[CWIID_Z]) *
-    EARTH_GRAVITY_;
-
-  imu_data_data.linear_acceleration_covariance = linear_acceleration_covariance_;
-
-  // MotionPlus Gyro
-  if (is_present_motionplus()) {
-    imu_data_data.angular_velocity.x = (wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_PHI]) *
-      GYRO_SCALE_FACTOR_;
-    imu_data_data.angular_velocity.y = (wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_THETA]) *
-      GYRO_SCALE_FACTOR_;
-    imu_data_data.angular_velocity.z = (wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_PSI]) *
-      GYRO_SCALE_FACTOR_;
-  }
-
-  imu_data_data.angular_velocity_covariance = angular_velocity_covariance_;
-
-  imu_data_pub_->publish(imu_data_data);
-}
-
-void WiimoteNode::publish_wiimote_state()
-{
-  wiimote_msgs::msg::State wiimote_state_data;
-
-  wiimote_state_data.header.stamp.sec = state_secs_;
-  wiimote_state_data.header.stamp.nanosec = state_nsecs_;
-
-  // Wiimote data
-  wiimote_state_data.linear_acceleration_zeroed.x =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_X], wiimote_cal_.zero[CWIID_X], wiimote_cal_.one[CWIID_X]) *
-    EARTH_GRAVITY_;
-  wiimote_state_data.linear_acceleration_zeroed.y =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_Y], wiimote_cal_.zero[CWIID_Y], wiimote_cal_.one[CWIID_Y]) *
-    EARTH_GRAVITY_;
-  wiimote_state_data.linear_acceleration_zeroed.z =
-    zeroedByCal(
-    wiimote_state_.acc[CWIID_Z], wiimote_cal_.zero[CWIID_Z], wiimote_cal_.one[CWIID_Z]) *
-    EARTH_GRAVITY_;
-
-  wiimote_state_data.linear_acceleration_raw.x = wiimote_state_.acc[CWIID_X];
-  wiimote_state_data.linear_acceleration_raw.y = wiimote_state_.acc[CWIID_Y];
-  wiimote_state_data.linear_acceleration_raw.z = wiimote_state_.acc[CWIID_Z];
-
-  wiimote_state_data.linear_acceleration_covariance = linear_acceleration_covariance_;
-
-  // MotionPlus Gyro
-  wiimote_state_data.angular_velocity_covariance = angular_velocity_covariance_;
-
-  if (is_present_motionplus()) {
-    wiimote_state_data.angular_velocity_zeroed.x =
-      (wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_PHI]) *
-      GYRO_SCALE_FACTOR_;
-    wiimote_state_data.angular_velocity_zeroed.y =
-      (wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_THETA]) *
-      GYRO_SCALE_FACTOR_;
-    wiimote_state_data.angular_velocity_zeroed.z =
-      (wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI] -
-      angular_velocity_stat_.getMeanRaw()[CWIID_PSI]) *
-      GYRO_SCALE_FACTOR_;
-
-    wiimote_state_data.angular_velocity_raw.x = wiimote_state_.ext.motionplus.angle_rate[CWIID_PHI];
-    wiimote_state_data.angular_velocity_raw.y =
-      wiimote_state_.ext.motionplus.angle_rate[CWIID_THETA];
-    wiimote_state_data.angular_velocity_raw.z = wiimote_state_.ext.motionplus.angle_rate[CWIID_PSI];
-  }
-
-  // NOTE: Order is different for /joy
-  // Keep consistency with existing Python Node
-  wiimote_state_data.buttons[0] = ((wiimote_state_.buttons & CWIID_BTN_1) > 0);
-  wiimote_state_data.buttons[1] = ((wiimote_state_.buttons & CWIID_BTN_2) > 0);
-  wiimote_state_data.buttons[2] = ((wiimote_state_.buttons & CWIID_BTN_PLUS) > 0);
-  wiimote_state_data.buttons[3] = ((wiimote_state_.buttons & CWIID_BTN_MINUS) > 0);
-  wiimote_state_data.buttons[4] = ((wiimote_state_.buttons & CWIID_BTN_A) > 0);
-  wiimote_state_data.buttons[5] = ((wiimote_state_.buttons & CWIID_BTN_B) > 0);
-  wiimote_state_data.buttons[6] = ((wiimote_state_.buttons & CWIID_BTN_UP) > 0);
-  wiimote_state_data.buttons[7] = ((wiimote_state_.buttons & CWIID_BTN_DOWN) > 0);
-  wiimote_state_data.buttons[8] = ((wiimote_state_.buttons & CWIID_BTN_LEFT) > 0);
-  wiimote_state_data.buttons[9] = ((wiimote_state_.buttons & CWIID_BTN_RIGHT) > 0);
-  wiimote_state_data.buttons[10] = ((wiimote_state_.buttons & CWIID_BTN_HOME) > 0);
-
-  // Nunchuk data
-  if (is_present_nunchuk()) {
-    if (publish_wiimote_nunchuk_common()) {
-      // Joy stick
-      double stick[2];
-
-      calculate_joystick_axis_xy(
-        wiimote_state_.ext.nunchuk.stick, nunchuk_stick_min_, nunchuk_stick_max_,
-        nunchuk_stick_center_, stick);
-
-      wiimote_state_data.nunchuk_joystick_raw[CWIID_X] = wiimote_state_.ext.nunchuk.stick[CWIID_X];
-      wiimote_state_data.nunchuk_joystick_raw[CWIID_Y] = wiimote_state_.ext.nunchuk.stick[CWIID_Y];
-
-      wiimote_state_data.nunchuk_joystick_zeroed[CWIID_X] = stick[CWIID_X];
-      wiimote_state_data.nunchuk_joystick_zeroed[CWIID_Y] = stick[CWIID_Y];
-
-      wiimote_state_data.nunchuk_acceleration_raw.x = wiimote_state_.ext.nunchuk.acc[CWIID_X];
-      wiimote_state_data.nunchuk_acceleration_raw.y = wiimote_state_.ext.nunchuk.acc[CWIID_Y];
-      wiimote_state_data.nunchuk_acceleration_raw.z = wiimote_state_.ext.nunchuk.acc[CWIID_Z];
-
-      wiimote_state_data.nunchuk_acceleration_zeroed.x =
-        zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_X], nunchuk_cal_.zero[CWIID_X],
-        nunchuk_cal_.one[CWIID_X]) *
-        EARTH_GRAVITY_;
-      wiimote_state_data.nunchuk_acceleration_zeroed.y =
-        zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_Y], nunchuk_cal_.zero[CWIID_Y],
-        nunchuk_cal_.one[CWIID_Y]) *
-        EARTH_GRAVITY_;
-      wiimote_state_data.nunchuk_acceleration_zeroed.z =
-        zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_Z], nunchuk_cal_.zero[CWIID_Z],
-        nunchuk_cal_.one[CWIID_Z]) *
-        EARTH_GRAVITY_;
-
-      // Keep consistency with existing Python Node
-      wiimote_state_data.nunchuk_buttons[0] =
-        ((wiimote_state_.ext.nunchuk.buttons & CWIID_NUNCHUK_BTN_Z) > 0);
-      wiimote_state_data.nunchuk_buttons[1] =
-        ((wiimote_state_.ext.nunchuk.buttons & CWIID_NUNCHUK_BTN_C) > 0);
-    }
-  }
-
-  // IR Tracking Data
-  for (int ir_idx = 0; ir_idx < CWIID_IR_SRC_COUNT; ir_idx++) {
-    wiimote_msgs::msg::IrSourceInfo irSourceInfo;
-
-    if (wiimote_state_.ir_src[ir_idx].valid) {
-      irSourceInfo.x = wiimote_state_.ir_src[ir_idx].pos[CWIID_X];
-      irSourceInfo.y = wiimote_state_.ir_src[ir_idx].pos[CWIID_Y];
-
-      irSourceInfo.ir_size = wiimote_state_.ir_src[ir_idx].size;
-
-      if (irSourceInfo.ir_size < 1) {
-        irSourceInfo.ir_size = wiimote_msgs::msg::State::INVALID;
-      }
-    } else {
-      irSourceInfo.x = wiimote_msgs::msg::State::INVALID_FLOAT;
-      irSourceInfo.y = wiimote_msgs::msg::State::INVALID_FLOAT;
-
-      irSourceInfo.ir_size = wiimote_msgs::msg::State::INVALID;
-    }
-
-    wiimote_state_data.ir_tracking.push_back(irSourceInfo);
-  }
-
-  // LEDs / Rumble
-  for (uint8_t i = 0; i < 4; i++) {
-    wiimote_state_data.leds[i] = wiimote_state_.led & (0x1 << i);
-  }
-  wiimote_state_data.rumble = wiimote_state_.rumble & 0x1;
-
-  // Battery
-  wiimote_state_data.raw_battery = wiimote_state_.battery;
-  wiimote_state_data.percent_battery = wiimote_state_.battery * 100.0 / CWIID_BATTERY_MAX;
-
-  // Zeroing time (aka Calibration time)
-  wiimote_state_data.zeroing_time = calibration_time_;
-
-  // Wiimote state errors
-  // No usage found in original Python code which every set this variable
-  // TODO(mdhorn): Use this to report error
-  // Is this a count? or a bunch of status that are ORed together?
-  wiimote_state_data.errors = wiimote_errors;
-
-  wiimote_state_pub_->publish(wiimote_state_data);
-}
-
-bool WiimoteNode::publish_wiimote_nunchuk_common()
-{
-  // Testing different Nunchuks show that they have different
-  // centers and different range of motion.
-  //
-  // Best Approximation:
-  // Grabbing the first set of x, y with the assumption of
-  // the joystick is centered.
-  // We know the joystick can only report between 0 and 255
-  // for each axis; so assume a 20% guard band to set the
-  // initial minimums and maximums. As the joystick is used,
-  // updated the min/max values based on observed data.
-  // This will have the effect of a less throw of the joystick
-  // throttle during first movement to the max/min position.
-  //
-  // TODO(mdhorn): Could be improved by a true user interaction calibration
-  // to find the center of the joystick, the max and min for each x and y.
-  // But the effort in coding and extra burden on the one the user
-  // may not be warranted.
-
-  bool result = true;
-
-  if (is_present_nunchuk()) {
-    if (!nunchuk_stick_calibrated_) {
-      nunchuk_stick_calibrated_ =
-        calibrate_joystick(wiimote_state_.ext.nunchuk.stick, nunchuk_stick_center_, "Nunchuk");
-
-      // Don't publish if we haven't found the center position
-      if (!nunchuk_stick_calibrated_) {
-        result = false;
-      }
-    }
-
-    update_joystick_min_max(
-      wiimote_state_.ext.nunchuk.stick, nunchuk_stick_min_, nunchuk_stick_max_, "Nunchuk");
-  } else {
-    RCLCPP_WARN(logger_, "State type is not Nunchuk!");
-    result = false;
-  }
-
-  return result;
-}
-
-void WiimoteNode::publish_wiimote_nunchuk()
-{
-  sensor_msgs::msg::Joy wiimote_nunchuk_data;
-
-  if (publish_wiimote_nunchuk_common()) {
-    wiimote_nunchuk_data.header.stamp.sec = state_secs_;
-    wiimote_nunchuk_data.header.stamp.nanosec = state_nsecs_;
-
-    // Joy stick
-    double stick[2];
-
-    calculate_joystick_axis_xy(
-      wiimote_state_.ext.nunchuk.stick, nunchuk_stick_min_, nunchuk_stick_max_,
-      nunchuk_stick_center_, stick);
-
-    wiimote_nunchuk_data.axes.push_back(stick[CWIID_X]);  // x
-    wiimote_nunchuk_data.axes.push_back(stick[CWIID_Y]);  // y
-
-    wiimote_nunchuk_data.axes.push_back(
-      zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_X], nunchuk_cal_.zero[CWIID_X],
-        nunchuk_cal_.one[CWIID_X]) *
-      EARTH_GRAVITY_);
-    wiimote_nunchuk_data.axes.push_back(
-      zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_Y], nunchuk_cal_.zero[CWIID_Y],
-        nunchuk_cal_.one[CWIID_Y]) *
-      EARTH_GRAVITY_);
-    wiimote_nunchuk_data.axes.push_back(
-      zeroedByCal(
-        wiimote_state_.ext.nunchuk.acc[CWIID_Z], nunchuk_cal_.zero[CWIID_Z],
-        nunchuk_cal_.one[CWIID_Z]) *
-      EARTH_GRAVITY_);
-
-    // NOTE: Order is different for /wiimote/state
-    // Keep consistency with existing Python Node
-    wiimote_nunchuk_data.buttons.push_back(
-      (wiimote_state_.ext.nunchuk.buttons & CWIID_NUNCHUK_BTN_Z) > 0);
-    wiimote_nunchuk_data.buttons.push_back(
-      (wiimote_state_.ext.nunchuk.buttons & CWIID_NUNCHUK_BTN_C) > 0);
-
-    wiimote_nunchuk_pub_->publish(wiimote_nunchuk_data);
-  }
-}
-void WiimoteNode::publish_wiimote_classic()
-{
-  // Using the same "Best Approximation" methods from
-  // WiimoteNode::publish_wiimote_nunchuk()
-
-  sensor_msgs::msg::Joy wiimote_classic_data;
-
-  if (is_present_classic()) {
-    RCLCPP_WARN(logger_, "State type is not Classic!");
-    return;
-  }
-
-  if (!classic_stick_left_calibrated_) {
-    classic_stick_left_calibrated_ = calibrate_joystick(
-      wiimote_state_.ext.classic.l_stick, classic_stick_left_center_, "Classic Left");
-  }
-
-  if (!classic_stick_right_calibrated_) {
-    classic_stick_right_calibrated_ = calibrate_joystick(
-      wiimote_state_.ext.classic.r_stick, classic_stick_right_center_, "Classic Right");
-  }
-
-  if ((!classic_stick_left_calibrated_) || (!classic_stick_right_calibrated_)) {
-    // Don't publish if we haven't found the center positions
-    return;
-  }
-
-  update_joystick_min_max(
-    wiimote_state_.ext.classic.l_stick, classic_stick_left_min_, classic_stick_left_max_,
-    "Classic Left");
-  update_joystick_min_max(
-    wiimote_state_.ext.classic.r_stick, classic_stick_right_min_, classic_stick_right_max_,
-    "Classic Right");
-
-  wiimote_classic_data.header.stamp.sec = state_secs_;
-  wiimote_classic_data.header.stamp.nanosec = state_nsecs_;
-
-  // Joy stick
-  double stick_left[2];
-  double stick_right[2];
-
-  calculate_joystick_axis_xy(
-    wiimote_state_.ext.classic.l_stick, classic_stick_left_min_, classic_stick_left_max_,
-    classic_stick_left_center_, stick_left);
-  calculate_joystick_axis_xy(
-    wiimote_state_.ext.classic.r_stick, classic_stick_right_min_, classic_stick_right_max_,
-    classic_stick_right_center_, stick_right);
-
-  wiimote_classic_data.axes.push_back(stick_left[CWIID_X]);   // Left x
-  wiimote_classic_data.axes.push_back(stick_left[CWIID_Y]);   // Left y
-  wiimote_classic_data.axes.push_back(stick_right[CWIID_X]);  // Right x
-  wiimote_classic_data.axes.push_back(stick_right[CWIID_Y]);  // Right y
-
-  // NOTE: Order is different for /wiimote/state
-  // Keep consistency with existing Python Node
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_X) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_Y) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_A) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_B) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_PLUS) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_MINUS) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_LEFT) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_RIGHT) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_UP) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_DOWN) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_HOME) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_L) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_R) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_ZL) > 0);
-  wiimote_classic_data.buttons.push_back(
-    (wiimote_state_.ext.classic.buttons & CWIID_CLASSIC_BTN_ZR) > 0);
-
-  wiimote_classic_pub_->publish(wiimote_classic_data);
-}
-
-bool WiimoteNode::calibrate_joystick(uint8_t * stick, uint8_t (& center)[2], const char * name)
-{
-  bool is_calibrated = false;
-
-  // Grab the current Joystick position as center
-  // If it is not reporting 0, 0
-  if (stick[CWIID_X] != 0 && stick[CWIID_Y] != 0) {
-    center[CWIID_X] = stick[CWIID_X];
-    center[CWIID_Y] = stick[CWIID_Y];
-
-    is_calibrated = true;
-
-    RCLCPP_DEBUG(
-      logger_, "%s Joystick Center:: x:%d, y:%d", name, center[CWIID_X], center[CWIID_Y]);
-  }
-
-  return is_calibrated;
-}
-
-void WiimoteNode::update_joystick_min_max(
-  uint8_t * stick, uint8_t (& stick_min)[2], uint8_t (& stick_max)[2], const char * name)
-{
-  bool updated = false;
-
-  if (stick[CWIID_X] < stick_min[CWIID_X]) {
-    stick_min[CWIID_X] = stick[CWIID_X];
-    updated = true;
-  }
-
-  if (stick[CWIID_Y] < stick_min[CWIID_Y]) {
-    stick_min[CWIID_Y] = stick[CWIID_Y];
-    updated = true;
-  }
-
-  if (stick[CWIID_X] > stick_max[CWIID_X]) {
-    stick_max[CWIID_X] = stick[CWIID_X];
-    updated = true;
-  }
-
-  if (stick[CWIID_Y] > stick_max[CWIID_Y]) {
-    stick_max[CWIID_Y] = stick[CWIID_Y];
-    updated = true;
-  }
-
-  if (updated) {
-    RCLCPP_DEBUG(
-      logger_, "%s Joystick:: Min x:%3d, y:%3d  Max x:%3d, y:%3d", name, stick_min[CWIID_X],
-      stick_min[CWIID_Y], stick_max[CWIID_X], stick_max[CWIID_Y]);
-  }
-}
-
-void WiimoteNode::calculate_joystick_axis_xy(
-  uint8_t * stick_current, uint8_t * stick_min, uint8_t * stick_max, uint8_t * stick_center,
-  double (& stick)[2])
-{
-  double deadzone[2];
-  int deadzoneMargin = 4;
-
-  // Scale the Wiimote Joystick integer values (0-31, 63, or 255)
-  // to a double value between 0.0 and 1.0.
-
-  // The width of the center deadzone needs to scale
-  // with the resolution of the joystick in use.
-  // Nunchuk range is 0-255; defaults to 4
-  // Classic Left range is 0-63; set to 2
-  // Classic Right range is 0-31; set to 1
-  // Original Python implementation was always 0.05 for all
-
-  // Optimize for Nunchuk case; most common
-  if (stick_max[CWIID_X] < 128) {
-    if (stick_max[CWIID_X] < 32) {
-      deadzoneMargin = 1;
-    } else if (stick_max[CWIID_X] < 64) {
-      deadzoneMargin = 2;
-    } else {
-      // No known wiimote joystick uses this range
-      deadzoneMargin = 3;
-    }
-  }
-
-  if (stick_current[CWIID_X] > stick_center[CWIID_X]) {
-    stick[CWIID_X] = -(stick_current[CWIID_X] - stick_center[CWIID_X]) /
-      ((stick_max[CWIID_X] - stick_center[CWIID_X]) * 1.0);
-    deadzone[CWIID_X] = deadzoneMargin / ((stick_max[CWIID_X] - stick_center[CWIID_X]) * 1.0);
-  } else {
-    stick[CWIID_X] = -(stick_current[CWIID_X] - stick_center[CWIID_X]) /
-      ((stick_center[CWIID_X] - stick_min[CWIID_X]) * 1.0);
-    deadzone[CWIID_X] = deadzoneMargin / ((stick_center[CWIID_X] - stick_min[CWIID_X]) * 1.0);
-  }
-  if (stick_current[CWIID_Y] > stick_center[CWIID_Y]) {
-    stick[CWIID_Y] = (stick_current[CWIID_Y] - stick_center[CWIID_Y]) /
-      ((stick_max[CWIID_Y] - stick_center[CWIID_Y]) * 1.0);
-    deadzone[CWIID_Y] = deadzoneMargin / ((stick_max[CWIID_Y] - stick_center[CWIID_Y]) * 1.0);
-  } else {
-    stick[CWIID_Y] = (stick_current[CWIID_Y] - stick_center[CWIID_Y]) /
-      ((stick_center[CWIID_Y] - stick_min[CWIID_Y]) * 1.0);
-    deadzone[CWIID_Y] = deadzoneMargin / ((stick_center[CWIID_Y] - stick_min[CWIID_Y]) * 1.0);
-  }
-
-  // Create a deadzone in the center
-  if (fabs(stick[CWIID_X]) <= deadzone[CWIID_X]) {
-    stick[CWIID_X] = 0.0;
-  }
-  if (fabs(stick[CWIID_Y]) <= deadzone[CWIID_Y]) {
-    stick[CWIID_Y] = 0.0;
-  }
-}
-
-#include <rclcpp_components/register_node_macro.hpp> //NOLINT
-RCLCPP_COMPONENTS_REGISTER_NODE(WiimoteNode)
diff --git a/wiimote/wiimote-extras.cmake b/wiimote/wiimote-extras.cmake
deleted file mode 100644
index f5b0d76..0000000
--- a/wiimote/wiimote-extras.cmake
+++ /dev/null
@@ -1,54 +0,0 @@
-# Copyright 2021 Intel Corporation
-# This program is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# This program is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this program.  If not, see <https://www.gnu.org/licenses/>.
-
-find_library(BLUETOOTH_LIB bluetooth)
-if(BLUETOOTH_LIB)
-  message(STATUS "Found bluetooth library.")
-else()
-  message(FATAL_ERROR "bluetooth library not found.")
-endif()
-
-find_path(BLUETOOTH_INCLUDE_DIR bluetooth/bluetooth.h)
-if(BLUETOOTH_LIB)
-  message(STATUS "Found bluetooth header.")
-else()
-  message(FATAL_ERROR "bluetooth header not found.")
-endif()
-
-find_library(CWIID_LIB cwiid)
-if(CWIID_LIB)
-  message(STATUS "Found cwiid library.")
-else()
-  message(FATAL_ERROR "cwiid library not found.")
-endif()
-
-find_path(CWIID_INCLUDE_DIR cwiid.h)
-if(CWIID_LIB)
-  message(STATUS "Found cwiid header.")
-else()
-  message(FATAL_ERROR "cwiid header not found.")
-endif()
-
-add_library(wiimote::bluetooth INTERFACE IMPORTED)
-target_link_libraries(wiimote::bluetooth INTERFACE ${BLUETOOTH_LIB})
-target_include_directories(wiimote::bluetooth INTERFACE ${BLUETOOTH_INCLUDE_DIR})
-
-add_library(wiimote::cwiid INTERFACE IMPORTED)
-target_link_libraries(wiimote::cwiid INTERFACE ${CWIID_LIB})
-target_include_directories(wiimote::cwiid INTERFACE ${CWIID_INCLUDE_DIR})
-
-unset(BLUETOOTH_LIB)
-unset(BLUETOOTH_INCLUDE_DIR)
-unset(CWIID_LIB)
-unset(CWIID_INCLUDE_DIR)
diff --git a/wiimote_msgs/CHANGELOG.rst b/wiimote_msgs/CHANGELOG.rst
deleted file mode 100644
index 13e35f5..0000000
--- a/wiimote_msgs/CHANGELOG.rst
+++ /dev/null
@@ -1,68 +0,0 @@
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-Changelog for package wiimote_msgs
-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
-
-3.1.0 (2022-01-28)
-------------------
-
-3.0.1 (2022-01-28)
-------------------
-
-3.0.0 (2021-03-12)
-------------------
-* Port over Wiimote to ROS2 Foxy (`#175 <https://github.com/ros-drivers/joystick_drivers/issues/175>`_)
-* Contributors: Kuni Natsuki
-
-2.4.1 (2020-05-13)
-------------------
-
-2.4.0 (2020-05-12)
-------------------
-
-1.13.0 (2019-06-24)
--------------------
-
-1.12.0 (2018-06-11)
--------------------
-
-1.11.0 (2017-02-11)
--------------------
-
-1.10.1 (2015-05-24)
--------------------
-
-1.10.0 (2014-06-26)
--------------------
-
-1.9.10 (2013-04-29)
--------------------
-
-1.9.9 (2013-03-13)
-------------------
-
-1.9.8 (2013-02-03)
-------------------
-
-1.9.7 (2013-01-22)
-------------------
-
-1.9.6 (2012-12-20)
-------------------
-
-1.9.5 (2012-12-14)
-------------------
-
-1.9.4 (2012-11-06)
-------------------
-
-1.9.3 (2012-11-04 23:46)
-------------------------
-
-1.9.2 (2012-11-04 08:53)
-------------------------
-
-1.9.1 (2012-11-04 01:56)
-------------------------
-
-1.9.0 (2012-11-03)
-------------------
diff --git a/wiimote_msgs/CMakeLists.txt b/wiimote_msgs/CMakeLists.txt
deleted file mode 100644
index 28db319..0000000
--- a/wiimote_msgs/CMakeLists.txt
+++ /dev/null
@@ -1,44 +0,0 @@
-cmake_minimum_required(VERSION 3.5)
-project(wiimote_msgs)
-
-# Default to C99
-if(NOT CMAKE_C_STANDARD)
-  set(CMAKE_C_STANDARD 99)
-endif()
-
-# Default to C++14
-if(NOT CMAKE_CXX_STANDARD)
-  set(CMAKE_CXX_STANDARD 14)
-endif()
-
-if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
-  add_compile_options(-Wall -Wextra -Wpedantic)
-endif()
-
-# find dependencies
-find_package(ament_cmake REQUIRED)
-find_package(ament_cmake_auto REQUIRED)
-
-ament_auto_find_build_dependencies(
-  REQUIRED
-  builtin_interfaces
-  geometry_msgs
-  rosidl_default_generators
-  std_msgs
-)
-
-if(BUILD_TESTING)
-  find_package(ament_lint_auto REQUIRED)
-  ament_lint_auto_find_test_dependencies()
-endif()
-
-# generate the messages
-rosidl_generate_interfaces(${PROJECT_NAME}
-  "msg/IrSourceInfo.msg"
-  "msg/State.msg"
-  "msg/TimedSwitch.msg"
-  DEPENDENCIES geometry_msgs std_msgs builtin_interfaces
-  ADD_LINTER_TESTS)
-
-ament_export_dependencies(rosidl_default_runtime)
-ament_package()
diff --git a/wiimote_msgs/msg/IrSourceInfo.msg b/wiimote_msgs/msg/IrSourceInfo.msg
deleted file mode 100644
index 78d3316..0000000
--- a/wiimote_msgs/msg/IrSourceInfo.msg
+++ /dev/null
@@ -1,21 +0,0 @@
-# Sensor data pertaining to the Wiimote infrared camera.
-# This message contains data for one of the four infrared
-# light sources that the camera detects.
-#
-# Each light is specified with a 2D position and
-# a 'source magnitude' (ir_size). If the x dimension
-# is set to INVALID_FLOAT, then no light was detected for
-# the respective light. The Wiimote handles up to
-# four light sources, and the wiimote_controller software
-# is written to that limit as well.
-#
-# I am unsure what the 'ir_size' values represent.
-# They are described as 'source magnitude' in some places. I
-# *assume* this is signal amplitude, but it's unclear.
-# Note that current lowest level cwiid driver does not
-# seem to pass the ir_size value to the cwiid Wiimote.c.
-# For now this size will therefore be set INVALID
-
-float64 x
-float64 y
-int64 ir_size
diff --git a/wiimote_msgs/msg/State.msg b/wiimote_msgs/msg/State.msg
deleted file mode 100644
index 72522a5..0000000
--- a/wiimote_msgs/msg/State.msg
+++ /dev/null
@@ -1,138 +0,0 @@
-#
-#          Wiimote State message containing one complete Wiimote state
-
-# Note: For ease of manipulation this message often uses
-#       int8[] when a bit vector would work. One might
-#       wish to use uint8[], but then Python takes
-#       the respective structure as a string and disallows
-#       item assignment.
-
-int8    INVALID       = -1
-float32 INVALID_FLOAT = -1.0
-
-int8 MSG_BTN_1     = 0
-int8 MSG_BTN_2     = 1
-int8 MSG_BTN_A     = 2
-int8 MSG_BTN_B     = 3
-int8 MSG_BTN_PLUS  = 4
-int8 MSG_BTN_MINUS = 5
-int8 MSG_BTN_LEFT  = 6
-int8 MSG_BTN_RIGHT = 7
-int8 MSG_BTN_UP    = 8
-int8 MSG_BTN_DOWN  = 9
-int8 MSG_BTN_HOME  = 10
-int8 MSG_BTN_Z     = 0
-int8 MSG_BTN_C     = 1
-int8 MSG_CLASSIC_BTN_X       = 0
-int8 MSG_CLASSIC_BTN_Y       = 1
-int8 MSG_CLASSIC_BTN_A       = 2
-int8 MSG_CLASSIC_BTN_B       = 3
-int8 MSG_CLASSIC_BTN_PLUS    = 4
-int8 MSG_CLASSIC_BTN_MINUS   = 5
-int8 MSG_CLASSIC_BTN_LEFT    = 6
-int8 MSG_CLASSIC_BTN_RIGHT   = 7
-int8 MSG_CLASSIC_BTN_UP      = 8
-int8 MSG_CLASSIC_BTN_DOWN    = 9
-int8 MSG_CLASSIC_BTN_HOME    = 10
-int8 MSG_CLASSIC_BTN_L       = 11
-int8 MSG_CLASSIC_BTN_R       = 12
-int8 MSG_CLASSIC_BTN_ZL      = 13
-int8 MSG_CLASSIC_BTN_ZR      = 14
-
-#-----------------------------
-# Header
-#----------------------
-
-std_msgs/Header header
-
-#----------------------
-# Gyro reading
-#-----------------------------
-# In radians/sec. If reading is invalid,
-# for instance b/c no gyro is attached to the Wii, then
-# set first element of covariance to -1 (same as imu_data.msg):
-# Covariance matrix (roll, pitch, yaw) in radians^2/sec^2.
-
-geometry_msgs/Vector3 angular_velocity_zeroed
-geometry_msgs/Vector3 angular_velocity_raw
-float64[9] angular_velocity_covariance
-
-#----------------------
-# Accelerometer reading
-#-----------------------------
-# Acceleration in m/sec^2. Covariance matrix
-# (x,y,z) in m^2/sec^4.  (all same as imu_data.msg)
-
-geometry_msgs/Vector3 linear_acceleration_zeroed
-geometry_msgs/Vector3 linear_acceleration_raw
-float64[9] linear_acceleration_covariance
-
-#------------------------------
-# Nunchuk Accelerometer reading
-#------------------------------
-geometry_msgs/Vector3 nunchuk_acceleration_zeroed
-geometry_msgs/Vector3 nunchuk_acceleration_raw
-
-#-----------------
-# Nunchuk Joystick
-#-----------------
-float32[2] nunchuk_joystick_zeroed
-float32[2] nunchuk_joystick_raw
-
-#----------------------
-# Wiimote buttons
-#-----------------------------
-# Mappings from Wiimote button name
-# to array position are defined above.
-#
-bool[11] buttons
-bool[2] nunchuk_buttons
-
-#----------------------
-# Wiimote LED states:
-#-----------------------------
-
-bool[4] leds
-
-#----------------------
-# Wiimote Rumble
-#-----------------------------
-# State (True or False)
-
-bool rumble
-
-#----------------------
-# IR Light sensor (Camera)
-#-----------------------------
-# The Wiimote handles up to four light sources, 
-# and the wiimote_controller software is written to
-# that limit as well. For future expansion
-# we make the following array extensible, rather
-# than locking its length down to four:
-
-wiimote_msgs/IrSourceInfo[] ir_tracking
-
-#----------------------
-# Wiimote battery
-#-----------------------------
-# A battery reading consists of two numbers: 
-# the battery percentage, and the raw reading.
-# Maximum battery is 208 units (unknown how this
-# relates to electrical properties): 
-
-float32 raw_battery
-float32 percent_battery
-
-#----------------------
-# Time of most recent zeroing:
-#-----------------------------
-
-builtin_interfaces/Time zeroing_time
-
-#----------------------
-# Error vector
-#-----------------------------
-# For error condition definitions see wiimoteConstants.py
-# Value of zero means all is well. (Currently NOT used).
-
-uint64 errors
diff --git a/wiimote_msgs/msg/TimedSwitch.msg b/wiimote_msgs/msg/TimedSwitch.msg
deleted file mode 100644
index a73685e..0000000
--- a/wiimote_msgs/msg/TimedSwitch.msg
+++ /dev/null
@@ -1,38 +0,0 @@
-# TimedSwitch allows sender to:
-#    o turn a switch on,
-#    o turn a switch off, and
-#    o repeat an on/off pattern forever or for a
-#          given number of times.
-# Fields (refer to definitions of constants in the definition body):
-#     o switch_mode:
-#         ON: turn on  (num_cycles and pulse_pattern fields are ignored)
-#        OFF: turn off (num_cycles and pulse_pattern fields are ignored)
-#  NO_CHANGE: leave LED in its current state
-#     REPEAT: repeat an on/off pattern for as long
-#             as is indicated in the num_cycles field. The
-#             pattern is defined in the pulse_pattern field.
-#
-#     o num_cycles:
-#          n>=0: run the pattern that is defined in pulse_pattern
-#                n times.
-#          n==FOREVER: run the pattern that is defined in pulse_pattern
-#                       until a new TimedSwitch message is sent.
-#
-#     o pulse_pattern:
-#          A series of time durations in fractions of a second. The
-#          first number is the duration for having the switch on.
-#          The second number is the duration for which the switch
-#          is off. The third is an 'on' period again, etc.
-#          A pattern is terminated with the end of the array.
-#
-#          Example: [1,1] specifies an on-off sequence of 1 second.
-
-int8 ON        =  1
-int8 OFF       =  0
-int8 NO_CHANGE = -2
-int8 REPEAT    = -1
-int8 FOREVER   = -1
-
-int8 switch_mode
-int32 num_cycles
-float32[] pulse_pattern
diff --git a/wiimote_msgs/package.xml b/wiimote_msgs/package.xml
deleted file mode 100644
index e4316f3..0000000
--- a/wiimote_msgs/package.xml
+++ /dev/null
@@ -1,41 +0,0 @@
-<?xml version="1.0"?>
-<?xml-model
-    href="http://download.ros.org/schema/package_format3.xsd"
-    schematypens="http://www.w3.org/2001/XMLSchema"?>
-<package format="3">
-  <name>wiimote_msgs</name>
-  <version>3.1.0</version>
-  <description>
-    Messages used by wiimote package.
-  </description>
-
-  <maintainer email="jbo@jhu.edu">Jonathan Bohren</maintainer>
-  <license>BSD</license>
-
-  <url type="website">http://www.ros.org/wiki/wiimote</url>
-  <url type="repository">https://github.com/ros-drivers/joystick_drivers</url>
-  <url type="bugtracker">https://github.com/ros-drivers/joystick_drivers/issues</url>
-
-  <author>Andreas Paepcke</author>
-  <author>Melonee Wise</author>
-  <author email="mark.d.horn@intel.com">Mark Horn</author>
-
-
-  <buildtool_depend>ament_cmake</buildtool_depend>
-  <buildtool_depend>ament_cmake_auto</buildtool_depend>
-  <buildtool_depend>rosidl_default_generators</buildtool_depend>
-
-  <exec_depend>rosidl_default_runtime</exec_depend>
-
-  <depend>builtin_interfaces</depend>
-  <depend>geometry_msgs</depend>
-  <depend>std_msgs</depend>
-
-  <test_depend>ament_lint_auto</test_depend>
-  <test_depend>ament_lint_common</test_depend>
-
-  <member_of_group>rosidl_interface_packages</member_of_group>
-  <export>
-    <build_type>ament_cmake</build_type>
-  </export>
-</package>
